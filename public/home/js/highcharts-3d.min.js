!function (e) { "object" == typeof module && module.exports ? module.exports = e.default = e : "function" == typeof define && define.amd ? define("highcharts/highcharts-3d", ["highcharts"], function (t) { return e(t), e.Highcharts = t, e }) : e("undefined" != typeof Highcharts ? Highcharts : void 0) }(function (t) { function e(t, e, i, o) { t.hasOwnProperty(e) || (t[e] = o.apply(null, i)) } e(t = t ? t._modules : {}, "Extensions/Math3D.js", [t["Core/Globals.js"], t["Core/Utilities.js"]], function (t, e) { var d = e.pick, x = t.deg2rad, y = t.perspective3D = function (t, e, i) { return e = 0 < i && i < Number.POSITIVE_INFINITY ? i / (t.z + e.z + i) : 1, { x: t.x * e, y: t.y * e } }, o = t.perspective = function (t, e, i, o) { var s = e.options.chart.options3d, r = d(o, !!i && e.inverted), a = { x: e.plotWidth / 2, y: e.plotHeight / 2, z: s.depth / 2, vd: d(s.depth, 1) * d(s.viewDistance, 0) }, n = e.scale3d || 1; o = x * s.beta * (r ? -1 : 1), s = x * s.alpha * (r ? -1 : 1); var h = Math.cos(s), l = Math.cos(-o), p = Math.sin(s), c = Math.sin(-o); return i || (a.x += e.plotLeft, a.y += e.plotTop), t.map(function (t) { var e = (r ? t.y : t.x) - a.x, i = (r ? t.x : t.y) - a.y; return t = (t.z || 0) - a.z, (i = y(e = { x: l * e - c * t, y: -p * c * e + h * i - l * p * t, z: h * c * e + p * i + h * l * t }, a, a.vd)).x = i.x * n + a.x, i.y = i.y * n + a.y, i.z = e.z * n + a.z, { x: r ? i.y : i.x, y: r ? i.x : i.y, z: i.z } }) }; e = t.pointCameraDistance = function (t, e) { var i = e.options.chart.options3d, o = e.plotWidth / 2; return e = e.plotHeight / 2, i = d(i.depth, 1) * d(i.viewDistance, 0) + i.depth, Math.sqrt(Math.pow(o - d(t.plotX, t.x), 2) + Math.pow(e - d(t.plotY, t.y), 2) + Math.pow(i - d(t.plotZ, t.z), 2)) }; var s = t.shapeArea = function (t) { for (var e = 0, i = 0; i < t.length; i++) { var o = (i + 1) % t.length; e += t[i].x * t[o].y - t[o].x * t[i].y } return e / 2 }; return t = t.shapeArea3d = function (t, e, i) { return s(o(t, e, i)) }, { perspective: o, perspective3D: y, pointCameraDistance: e, shapeArea: s, shapeArea3D: t } }), e(t, "Core/Renderer/SVG/SVGRenderer3D.js", [t["Core/Color.js"], t["Core/Globals.js"], t["Extensions/Math3D.js"], t["Core/Renderer/SVG/SVGElement.js"], t["Core/Renderer/SVG/SVGRenderer.js"], t["Core/Utilities.js"]], function (t, l, e, p, i, o) { function m(t, e, i, o, s, r, a, n) { var h = [], l = r - s; return s < r && r - s > Math.PI / 2 + 1e-4 ? h = (h = h.concat(m(t, e, i, o, s, s + Math.PI / 2, a, n))).concat(m(t, e, i, o, s + Math.PI / 2, r, a, n)) : r < s && s - r > Math.PI / 2 + 1e-4 ? h = (h = h.concat(m(t, e, i, o, s, s - Math.PI / 2, a, n))).concat(m(t, e, i, o, s - Math.PI / 2, r, a, n)) : [["C", t + i * Math.cos(s) - i * f * l * Math.sin(s) + a, e + o * Math.sin(s) + o * f * l * Math.cos(s) + n, t + i * Math.cos(r) + i * f * l * Math.sin(r) + a, e + o * Math.sin(r) - o * f * l * Math.cos(r) + n, t + i * Math.cos(r) + a, e + o * Math.sin(r) + n]] } var r = t.parse, b = e.perspective, g = e.shapeArea, c = o.animObject, n = o.defined, a = o.extend, d = o.merge, h = o.objectEach, x = o.pick, M = Math.cos, A = Math.PI, P = Math.sin, v = l.charts, y = l.deg2rad, f = 4 * (Math.sqrt(2) - 1) / 3 / (A / 2); i.prototype.toLinePath = function (t, e) { var i = []; return t.forEach(function (t) { i.push(["L", t.x, t.y]) }), t.length && (i[0][0] = "M", e && i.push(["Z"])), i }, i.prototype.toLineSegments = function (t) { var e = [], i = !0; return t.forEach(function (t) { e.push(i ? ["M", t.x, t.y] : ["L", t.x, t.y]), i = !i }), e }, i.prototype.face3d = function (t) { var o = this, e = this.createElement("path"); return e.vertexes = [], e.insidePlotArea = !1, e.enabled = !0, e.attr = function (t) { var e, i; return "object" == typeof t && (n(t.enabled) || n(t.vertexes) || n(t.insidePlotArea)) && (this.enabled = x(t.enabled, this.enabled), this.vertexes = x(t.vertexes, this.vertexes), this.insidePlotArea = x(t.insidePlotArea, this.insidePlotArea), delete t.enabled, delete t.vertexes, delete t.insidePlotArea, i = b(this.vertexes, v[o.chartIndex], this.insidePlotArea), e = o.toLinePath(i, !0), i = g(i), i = this.enabled && 0 < i ? "visible" : "hidden", t.d = e, t.visibility = i), p.prototype.attr.apply(this, arguments) }, e.animate = function (t) { var e, i; return "object" == typeof t && (n(t.enabled) || n(t.vertexes) || n(t.insidePlotArea)) && (this.enabled = x(t.enabled, this.enabled), this.vertexes = x(t.vertexes, this.vertexes), this.insidePlotArea = x(t.insidePlotArea, this.insidePlotArea), delete t.enabled, delete t.vertexes, delete t.insidePlotArea, i = b(this.vertexes, v[o.chartIndex], this.insidePlotArea), e = o.toLinePath(i, !0), i = g(i), i = this.enabled && 0 < i ? "visible" : "hidden", t.d = e, this.attr("visibility", i)), p.prototype.animate.apply(this, arguments) }, e.attr(t) }, i.prototype.polyhedron = function (t) { var r = this, a = this.g(), e = a.destroy; return this.styledMode || a.attr({ "stroke-linejoin": "round" }), a.faces = [], a.destroy = function () { for (var t = 0; t < a.faces.length; t++)a.faces[t].destroy(); return e.call(this) }, a.attr = function (t, e, i, o) { if ("object" == typeof t && n(t.faces)) { for (; a.faces.length > t.faces.length;)a.faces.pop().destroy(); for (; a.faces.length < t.faces.length;)a.faces.push(r.face3d().add(a)); for (var s = 0; s < t.faces.length; s++)r.styledMode && delete t.faces[s].fill, a.faces[s].attr(t.faces[s], null, i, o); delete t.faces } return p.prototype.attr.apply(this, arguments) }, a.animate = function (t, e, i) { if (t && t.faces) { for (; a.faces.length > t.faces.length;)a.faces.pop().destroy(); for (; a.faces.length < t.faces.length;)a.faces.push(r.face3d().add(a)); for (var o = 0; o < t.faces.length; o++)a.faces[o].animate(t.faces[o], e, i); delete t.faces } return p.prototype.animate.apply(this, arguments) }, a.attr(t) }; var s = d(t = { initArgs: function (t) { var e = this, i = e.renderer, o = i[e.pathType + "Path"](t), s = o.zIndexes; e.parts.forEach(function (t) { e[t] = i.path(o[t]).attr({ class: "highcharts-3d-" + t, zIndex: s[t] || 0 }).add(e) }), e.attr({ "stroke-linejoin": "round", zIndex: s.group }), e.originalDestroy = e.destroy, e.destroy = e.destroyParts, e.forcedSides = o.forcedSides }, singleSetterForParts: function (i, t, o, e, s, r) { var a = {}; e = [null, null, e || "attr", s, r]; var n = o && o.zIndexes; return o ? (n && n.group && this.attr({ zIndex: n.group }), h(o, function (t, e) { a[e] = {}, a[e][i] = t, n && (a[e].zIndex = o.zIndexes[e] || 0) }), e[1] = a) : (a[i] = t, e[0] = a), this.processParts.apply(this, e) }, processParts: function (e, i, o, s, r) { var a = this; return a.parts.forEach(function (t) { i && (e = x(i[t], !1)), !1 !== e && a[t][o](e, s, r) }), a }, destroyParts: function () { return this.processParts(null, null, "destroy"), this.originalDestroy() } }, { parts: ["front", "top", "side"], pathType: "cuboid", attr: function (t, e, i, o) { var s; return "string" == typeof t && void 0 !== e && (s = t, (t = {})[s] = e), t.shapeArgs || n(t.x) ? this.singleSetterForParts("d", null, this.renderer[this.pathType + "Path"](t.shapeArgs || t)) : p.prototype.attr.call(this, t, void 0, i, o) }, animate: function (t, e, i) { var o; return n(t.x) && n(t.y) ? (o = (t = this.renderer[this.pathType + "Path"](t)).forcedSides, this.singleSetterForParts("d", null, t, "animate", e, i), this.attr({ zIndex: t.zIndexes.group }), o !== this.forcedSides && (this.forcedSides = o, s.fillSetter.call(this, this.fill))) : p.prototype.animate.call(this, t, e, i), this }, fillSetter: function (t) { return this.forcedSides = this.forcedSides || [], this.singleSetterForParts("fill", null, { front: t, top: r(t).brighten(0 <= this.forcedSides.indexOf("top") ? 0 : .1).get(), side: r(t).brighten(0 <= this.forcedSides.indexOf("side") ? 0 : -.1).get() }), this.color = this.fill = t, this } }); i.prototype.elements3d = { base: t, cuboid: s }, i.prototype.element3d = function (t, e) { var i = this.g(); return a(i, this.elements3d[t]), i.initArgs(e), i }, i.prototype.cuboid = function (t) { return this.element3d("cuboid", t) }, i.prototype.cuboidPath = function (t) { function a(t) { return 0 === s && 1 < t && t < 6 ? { x: x[t].x, y: x[t].y + 10, z: x[t].z } : x[0].x === x[7].x && 4 <= t ? { x: x[t].x + 10, y: x[t].y, z: x[t].z } : 0 === h && t < 2 || 5 < t ? { x: x[t].x, y: x[t].y, z: x[t].z + 10 } : x[t] } function n(t) { return x[t] } var e = t.x, i = t.y, o = t.z || 0, s = t.height, r = t.width, h = t.depth, l = v[this.chartIndex], p = l.options.chart.options3d.alpha, c = 0, d = [], x = b(x = [{ x: e, y: i, z: o }, { x: e + r, y: i, z: o }, { x: e + r, y: i + s, z: o }, { x: e, y: i + s, z: o }, { x: e, y: i + s, z: o + h }, { x: e + r, y: i + s, z: o + h }, { x: e + r, y: i, z: o + h }, { x: e, y: i, z: o + h }], l, t.insidePlotArea), y = (z = function (t, e, i) { var o = [[], -1], s = t.map(n), r = e.map(n); return t = t.map(a), e = e.map(a), g(s) < 0 ? o = [s, 0] : g(r) < 0 ? o = [r, 1] : i && (d.push(i), o = !(g(t) < 0) && g(e) < 0 ? [r, 1] : [s, 0]), o })([3, 2, 1, 0], [7, 6, 5, 4], "front"); t = y[0]; var f = y[1], r = (y = z([1, 6, 7, 0], [4, 5, 2, 3], "top"))[0], u = y[1], z = (y = z([1, 2, 5, 6], [0, 7, 4, 3], "side"))[0]; return 1 === (y = y[1]) ? c += 1e6 * (l.plotWidth - e) : y || (c += 1e6 * e), c += 10 * (!u || 0 <= p && p <= 180 || p < 360 && 357.5 < p ? l.plotHeight - i : 10 + i), 1 === f ? c += 100 * o : f || (c += 100 * (1e3 - o)), { front: this.toLinePath(t, !0), top: this.toLinePath(r, !0), side: this.toLinePath(z, !0), zIndexes: { group: Math.round(c) }, forcedSides: d, isFront: f, isTop: u } }, i.prototype.arc3d = function (t) { function n(t) { var e, i = !1, o = {}; for (e in t = d(t)) -1 !== s.indexOf(e) && (o[e] = t[e], delete t[e], i = !0); return !!i && [o, t] } var h = this.g(), e = h.renderer, s = "x y r innerR start end depth".split(" "); return (t = d(t)).alpha = (t.alpha || 0) * y, t.beta = (t.beta || 0) * y, h.top = e.path(), h.side1 = e.path(), h.side2 = e.path(), h.inn = e.path(), h.out = e.path(), h.onAdd = function () { var e = h.parentGroup, i = h.attr("class"); h.top.add(h), ["out", "inn", "side1", "side2"].forEach(function (t) { h[t].attr({ class: i + " highcharts-3d-side" }).add(e) }) }, ["addClass", "removeClass"].forEach(function (i) { h[i] = function () { var e = arguments;["top", "out", "inn", "side1", "side2"].forEach(function (t) { h[t][i].apply(h[t], e) }) } }), h.setPaths = function (t) { var e = h.renderer.arc3dPath(t), i = 100 * e.zTop; h.attribs = t, h.top.attr({ d: e.top, zIndex: e.zTop }), h.inn.attr({ d: e.inn, zIndex: e.zInn }), h.out.attr({ d: e.out, zIndex: e.zOut }), h.side1.attr({ d: e.side1, zIndex: e.zSide1 }), h.side2.attr({ d: e.side2, zIndex: e.zSide2 }), h.zIndex = i, h.attr({ zIndex: i }), t.center && (h.top.setRadialReference(t.center), delete t.center) }, h.setPaths(t), h.fillSetter = function (t) { var e = r(t).brighten(-.1).get(); return this.fill = t, this.side1.attr({ fill: e }), this.side2.attr({ fill: e }), this.inn.attr({ fill: e }), this.out.attr({ fill: e }), this.top.attr({ fill: t }), this }, ["opacity", "translateX", "translateY", "visibility"].forEach(function (t) { h[t + "Setter"] = function (e, i) { h[i] = e, ["out", "inn", "side1", "side2", "top"].forEach(function (t) { h[t].attr(i, e) }) } }), h.attr = function (t) { var e, i; return "object" == typeof t && (e = n(t)) && (i = e[0], t = e[1], a(h.attribs, i), h.setPaths(h.attribs)), p.prototype.attr.apply(h, arguments) }, h.animate = function (t, e, i) { var o = this.attribs, s = "data-" + Math.random().toString(26).substring(2, 9); delete t.center, delete t.z, delete t.alpha, delete t.beta; var r, a = c(x(e, this.renderer.globalAnimation)); return a.duration && (e = n(t), h[s] = 0, t[s] = 1, h[s + "Setter"] = l.noop, e && (r = e[0], a.step = function (t, e) { function i(t) { return o[t] + (x(r[t], o[t]) - o[t]) * e.pos } e.prop === s && e.elem.setPaths(d(o, { x: i("x"), y: i("y"), r: i("r"), innerR: i("innerR"), start: i("start"), end: i("end"), depth: i("depth") })) }), e = a), p.prototype.animate.call(this, t, e, i) }, h.destroy = function () { return this.top.destroy(), this.out.destroy(), this.inn.destroy(), this.side1.destroy(), this.side2.destroy(), p.prototype.destroy.call(this) }, h.hide = function () { this.top.hide(), this.out.hide(), this.inn.hide(), this.side1.hide(), this.side2.hide() }, h.show = function (t) { this.top.show(t), this.out.show(t), this.inn.show(t), this.side1.show(t), this.side2.show(t) }, h }, i.prototype.arc3dPath = function (t) { function e(t) { return (t %= 2 * Math.PI) > Math.PI && (t = 2 * Math.PI - t), t } var i = t.x, o = t.y, s = t.start, r = t.end - 1e-5, a = t.r, n = t.innerR || 0, h = t.depth || 0, l = t.alpha, p = t.beta, c = Math.cos(s), d = Math.sin(s); t = Math.cos(r); var x = Math.sin(r), y = a * Math.cos(p); a *= Math.cos(l); var f = n * Math.cos(p), u = n * Math.cos(l), n = h * Math.sin(p), z = h * Math.sin(l); (h = (h = [["M", i + y * c, o + a * d]]).concat(m(i, o, y, a, s, r, 0, 0))).push(["L", i + f * t, o + u * x]), (h = h.concat(m(i, o, f, u, r, s, 0, 0))).push(["Z"]); var b = 0 < p ? Math.PI / 2 : 0, p = 0 < l ? 0 : Math.PI / 2, g = !(r < A - p) && s < A - p ? A - p : r, v = 2 * A - p; return l = (l = [["M", i + y * M(b = !(-b < s) && -b < r ? -b : s), o + a * P(b)]]).concat(m(i, o, y, a, b, g, 0, 0)), v < r && s < v ? (l.push(["L", i + y * M(g) + n, o + a * P(g) + z]), (l = l.concat(m(i, o, y, a, g, v, n, z))).push(["L", i + y * M(v), o + a * P(v)]), (l = l.concat(m(i, o, y, a, v, r, 0, 0))).push(["L", i + y * M(r) + n, o + a * P(r) + z]), (l = l.concat(m(i, o, y, a, r, v, n, z))).push(["L", i + y * M(v), o + a * P(v)]), l = l.concat(m(i, o, y, a, v, g, 0, 0))) : A - p < r && s < A - p && (l.push(["L", i + y * Math.cos(g) + n, o + a * Math.sin(g) + z]), (l = l.concat(m(i, o, y, a, g, r, n, z))).push(["L", i + y * Math.cos(r), o + a * Math.sin(r)]), l = l.concat(m(i, o, y, a, r, g, 0, 0))), l.push(["L", i + y * Math.cos(g) + n, o + a * Math.sin(g) + z]), (l = l.concat(m(i, o, y, a, g, b, n, z))).push(["Z"]), (p = (p = [["M", i + f * c, o + u * d]]).concat(m(i, o, f, u, s, r, 0, 0))).push(["L", i + f * Math.cos(r) + n, o + u * Math.sin(r) + z]), (p = p.concat(m(i, o, f, u, r, s, n, z))).push(["Z"]), c = [["M", i + y * c, o + a * d], ["L", i + y * c + n, o + a * d + z], ["L", i + f * c + n, o + u * d + z], ["L", i + f * c, o + u * d], ["Z"]], i = [["M", i + y * t, o + a * x], ["L", i + y * t + n, o + a * x + z], ["L", i + f * t + n, o + u * x + z], ["L", i + f * t, o + u * x], ["Z"]], x = Math.atan2(z, -n), o = Math.abs(r + x), t = Math.abs(s + x), s = Math.abs((s + r) / 2 + x), o = e(o), t = e(t), s = e(s), s *= 1e5, r = 1e5 * t, o *= 1e5, { top: h, zTop: 1e5 * Math.PI + 1, out: l, zOut: Math.max(s, r, o), inn: p, zInn: Math.max(s, r, o), side1: c, zSide1: .99 * o, side2: i, zSide2: .99 * r } } }), e(t, "Core/Axis/Tick3D.js", [t["Core/Utilities.js"]], function (t) { var e = t.addEvent, i = t.extend, o = t.wrap; return s.compose = function (t) { e(t, "afterGetLabelPosition", s.onAfterGetLabelPosition), o(t.prototype, "getMarkPath", s.wrapGetMarkPath) }, s.onAfterGetLabelPosition = function (t) { var e = this.axis.axis3D; e && i(t.pos, e.fix3dPosition(t.pos)) }, s.wrapGetMarkPath = function (t) { var e = this.axis.axis3D, i = t.apply(this, [].slice.call(arguments, 1)); if (e) { var o = i[0], s = i[1]; if ("M" === o[0] && "L" === s[0]) return e = [e.fix3dPosition({ x: o[1], y: o[2], z: 0 }), e.fix3dPosition({ x: s[1], y: s[2], z: 0 })], this.axis.chart.renderer.toLineSegments(e) } return i }, s; function s() { } }), e(t, "Core/Axis/Axis3D.js", [t["Core/Globals.js"], t["Extensions/Math3D.js"], t["Core/Axis/Tick.js"], t["Core/Axis/Tick3D.js"], t["Core/Utilities.js"]], function (t, e, i, o, s) { var f = e.perspective, p = e.perspective3D, u = e.shapeArea, r = s.addEvent, a = s.merge, z = s.pick, n = s.wrap, b = t.deg2rad, h = (l.prototype.fix3dPosition = function (t, e) { var i = this.axis, o = i.chart; if ("colorAxis" === i.coll || !o.chart3d || !o.is3d()) return t; var s = b * o.options.chart.options3d.alpha, r = b * o.options.chart.options3d.beta, a = z(e && i.options.title.position3d, i.options.labels.position3d); e = z(e && i.options.title.skew3d, i.options.labels.skew3d); var n = o.chart3d.frame3d, h = o.plotLeft, l = o.plotWidth + h, p = o.plotTop, c = o.plotHeight + p, o = !1, d = 0, x = 0, y = { x: 0, y: 1, z: 0 }; if (t = i.axis3D.swapZ({ x: t.x, y: t.y, z: 0 }), i.isZAxis) if (i.opposite) { if (null === n.axes.z.top) return {}; x = t.y - p, t.x = n.axes.z.top.x, t.y = n.axes.z.top.y, h = n.axes.z.top.xDir, o = !n.top.frontFacing } else { if (null === n.axes.z.bottom) return {}; x = t.y - c, t.x = n.axes.z.bottom.x, t.y = n.axes.z.bottom.y, h = n.axes.z.bottom.xDir, o = !n.bottom.frontFacing } else if (i.horiz) if (i.opposite) { if (null === n.axes.x.top) return {}; x = t.y - p, t.y = n.axes.x.top.y, t.z = n.axes.x.top.z, h = n.axes.x.top.xDir, o = !n.top.frontFacing } else { if (null === n.axes.x.bottom) return {}; x = t.y - c, t.y = n.axes.x.bottom.y, t.z = n.axes.x.bottom.z, h = n.axes.x.bottom.xDir, o = !n.bottom.frontFacing } else if (i.opposite) { if (null === n.axes.y.right) return {}; d = t.x - l, t.x = n.axes.y.right.x, t.z = n.axes.y.right.z, h = { x: (h = n.axes.y.right.xDir).z, y: h.y, z: -h.x } } else { if (null === n.axes.y.left) return {}; d = t.x - h, t.x = n.axes.y.left.x, t.z = n.axes.y.left.z, h = n.axes.y.left.xDir } return "chart" !== a && ("flap" === a ? i.horiz ? (r = Math.sin(s), s = Math.cos(s), i.opposite && (r = -r), o && (r = -r), y = { x: h.z * r, y: s, z: -h.x * r }) : h = { x: Math.cos(r), y: 0, z: Math.sin(r) } : "ortho" === a ? i.horiz ? (y = Math.cos(s), a = Math.sin(r) * y, s = -Math.sin(s), r = -y * Math.cos(r), y = { x: h.y * r - h.z * s, y: h.z * a - h.x * r, z: h.x * s - h.y * a }, s = 1 / Math.sqrt(y.x * y.x + y.y * y.y + y.z * y.z), o && (s = -s), y = { x: s * y.x, y: s * y.y, z: s * y.z }) : h = { x: Math.cos(r), y: 0, z: Math.sin(r) } : i.horiz ? y = { x: Math.sin(r) * Math.sin(s), y: Math.cos(s), z: -Math.cos(r) * Math.sin(s) } : h = { x: Math.cos(r), y: 0, z: Math.sin(r) }), t.x += d * h.x + x * y.x, t.y += d * h.y + x * y.y, t.z += d * h.z + x * y.z, o = f([t], i.chart)[0], e && (u(f([t, { x: t.x + h.x, y: t.y + h.y, z: t.z + h.z }, { x: t.x + y.x, y: t.y + y.y, z: t.z + y.z }], i.chart)) < 0 && (h = { x: -h.x, y: -h.y, z: -h.z }), t = f([{ x: t.x, y: t.y, z: t.z }, { x: t.x + h.x, y: t.y + h.y, z: t.z + h.z }, { x: t.x + y.x, y: t.y + y.y, z: t.z + y.z }], i.chart), o.matrix = [t[1].x - t[0].x, t[1].y - t[0].y, t[2].x - t[0].x, t[2].y - t[0].y, o.x, o.y], o.matrix[4] -= o.x * o.matrix[0] + o.y * o.matrix[2], o.matrix[5] -= o.x * o.matrix[1] + o.y * o.matrix[3]), o }, l.prototype.swapZ = function (t, e) { var i = this.axis; return i.isZAxis ? { x: (e = e ? 0 : i.chart.plotLeft) + t.z, y: t.y, z: t.x - e } : t }, l); function l(t) { this.axis = t } return c.compose = function (t) { a(!0, t.defaultOptions, c.defaultOptions), t.keepProps.push("axis3D"), r(t, "init", c.onInit), r(t, "afterSetOptions", c.onAfterSetOptions), r(t, "drawCrosshair", c.onDrawCrosshair), r(t, "destroy", c.onDestroy), t = t.prototype, n(t, "getLinePath", c.wrapGetLinePath), n(t, "getPlotBandPath", c.wrapGetPlotBandPath), n(t, "getPlotLinePath", c.wrapGetPlotLinePath), n(t, "getSlotWidth", c.wrapGetSlotWidth), n(t, "getTitlePosition", c.wrapGetTitlePosition), o.compose(i) }, c.onAfterSetOptions = function () { var t = this.chart, e = this.options; t.is3d && t.is3d() && "colorAxis" !== this.coll && (e.tickWidth = z(e.tickWidth, 0), e.gridLineWidth = z(e.gridLineWidth, 1)) }, c.onDestroy = function () { ["backFrame", "bottomFrame", "sideFrame"].forEach(function (t) { this[t] && (this[t] = this[t].destroy()) }, this) }, c.onDrawCrosshair = function (t) { this.chart.is3d() && "colorAxis" !== this.coll && t.point && (t.point.crosshairPos = this.isXAxis ? t.point.axisXpos : this.len - t.point.axisYpos) }, c.onInit = function () { this.axis3D || (this.axis3D = new h(this)) }, c.wrapGetLinePath = function (t) { return this.chart.is3d() && "colorAxis" !== this.coll ? [] : t.apply(this, [].slice.call(arguments, 1)) }, c.wrapGetPlotBandPath = function (t) { if (!this.chart.is3d() || "colorAxis" === this.coll) return t.apply(this, [].slice.call(arguments, 1)); var e = (o = arguments)[2], i = [], o = this.getPlotLinePath({ value: o[1] }), e = this.getPlotLinePath({ value: e }); if (o && e) for (var s = 0; s < o.length; s += 2) { var r = o[s], a = o[s + 1], n = e[s], h = e[s + 1]; "M" === r[0] && "L" === a[0] && "M" === n[0] && "L" === h[0] && i.push(r, a, h, ["L", n[1], n[2]], ["Z"]) } return i }, c.wrapGetPlotLinePath = function (t) { var e = this.axis3D, i = this.chart, o = t.apply(this, [].slice.call(arguments, 1)); if ("colorAxis" === this.coll || !i.chart3d || !i.is3d() || null === o) return o; var s = i.options.chart.options3d, r = this.isZAxis ? i.plotWidth : s.depth, s = i.chart3d.frame3d, a = o[0], n = o[1], o = []; return "M" === a[0] && "L" === n[0] && (e = [e.swapZ({ x: a[1], y: a[2], z: 0 }), e.swapZ({ x: a[1], y: a[2], z: r }), e.swapZ({ x: n[1], y: n[2], z: 0 }), e.swapZ({ x: n[1], y: n[2], z: r })], this.horiz ? (this.isZAxis ? (s.left.visible && o.push(e[0], e[2]), s.right.visible && o.push(e[1], e[3])) : (s.front.visible && o.push(e[0], e[2]), s.back.visible && o.push(e[1], e[3])), s.top.visible && o.push(e[0], e[1]), s.bottom.visible && o.push(e[2], e[3])) : (s.front.visible && o.push(e[0], e[2]), s.back.visible && o.push(e[1], e[3]), s.left.visible && o.push(e[0], e[1]), s.right.visible && o.push(e[2], e[3])), o = f(o, this.chart, !1)), i.renderer.toLineSegments(o) }, c.wrapGetSlotWidth = function (t, e) { var i = this.chart, o = this.ticks, s = this.gridGroup; if (this.categories && i.frameShapes && i.is3d() && s && e && e.label) { s = s.element.childNodes[0].getBBox(); var r, a, n = i.frameShapes.left.getBBox(), h = i.options.chart.options3d, i = { x: i.plotWidth / 2, y: i.plotHeight / 2, z: h.depth / 2, vd: z(h.depth, 1) * z(h.viewDistance, 0) }, l = o[(h = e.pos) - 1], o = o[h + 1]; return 0 !== h && l && l.label.xy && (r = p({ x: l.label.xy.x, y: l.label.xy.y, z: null }, i, i.vd)), o && o.label.xy && (a = p({ x: o.label.xy.x, y: o.label.xy.y, z: null }, i, i.vd)), o = { x: e.label.xy.x, y: e.label.xy.y, z: null }, o = p(o, i, i.vd), Math.abs(r ? o.x - r.x : a ? a.x - o.x : s.x - n.x) } return t.apply(this, [].slice.call(arguments, 1)) }, c.wrapGetTitlePosition = function (t) { var e = t.apply(this, [].slice.call(arguments, 1)); return this.axis3D ? this.axis3D.fix3dPosition(e, !0) : e }, c.defaultOptions = { labels: { position3d: "offset", skew3d: !1 }, title: { position3d: null, skew3d: null } }, c; function c() { } }), e(t, "Core/Axis/ZAxis.js", [t["Core/Axis/Axis.js"], t["Core/Utilities.js"]], function (t, e) { var i, o, s = this && this.__extends || (o = function (t, e) { return (o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) })(t, e) }, function (t, e) { function i() { this.constructor = t } o(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i) }), r = e.addEvent, a = e.merge, n = e.pick, h = e.splat, l = (d.compose = function (t) { r(t, "afterGetAxes", d.onAfterGetAxes), (t = t.prototype).addZAxis = d.wrapAddZAxis, t.collectionsWithInit.zAxis = [t.addZAxis], t.collectionsWithUpdate.push("zAxis") }, d.onAfterGetAxes = function () { var i = this, t = (t = this.options).zAxis = h(t.zAxis || {}); i.is3d() && (i.zAxis = [], t.forEach(function (t, e) { t.index = e, t.isX = !0, i.addZAxis(t).setScale() })) }, d.wrapAddZAxis = function (t) { return new p(this, t) }, d), p = (s(c, i = t), c.prototype.getSeriesExtremes = function () { var e = this, i = e.chart; e.hasVisibleSeries = !1, e.dataMin = e.dataMax = e.ignoreMinPadding = e.ignoreMaxPadding = void 0, e.stacking && e.stacking.buildStacks(), e.series.forEach(function (t) { !t.visible && i.options.chart && i.options.chart.ignoreHiddenSeries || (e.hasVisibleSeries = !0, (t = t.zData).length && (e.dataMin = Math.min(n(e.dataMin, t[0]), Math.min.apply(null, t)), e.dataMax = Math.max(n(e.dataMax, t[0]), Math.max.apply(null, t)))) }) }, c.prototype.setAxisSize = function () { var t = this.chart; i.prototype.setAxisSize.call(this), this.width = this.len = t.options.chart && t.options.chart.options3d && t.options.chart.options3d.depth || 0, this.right = t.chartWidth - this.width - this.left }, c.prototype.setOptions = function (t) { t = a({ offset: 0, lineWidth: 0 }, t), i.prototype.setOptions.call(this, t), this.coll = "zAxis" }, c.ZChartComposition = l, c); function c(t, e) { return (t = i.call(this, t, e) || this).isZAxis = !0, t } function d() { } return p }), e(t, "Core/Chart/Chart3D.js", [t["Core/Axis/Axis.js"], t["Core/Axis/Axis3D.js"], t["Core/Chart/Chart.js"], t["Core/Globals.js"], t["Extensions/Math3D.js"], t["Core/Options.js"], t["Core/Utilities.js"], t["Core/Axis/ZAxis.js"]], function (t, e, i, y, o, s, r, a) { var g = o.perspective, v = o.shapeArea3D, n = s.defaultOptions, h = r.addEvent; o = r.Fx; var l, p, c, d = r.isArray, x = r.merge, m = r.pick, f = r.wrap; function u(t) { this.is3d() && "scatter" === t.options.type && (t.options.type = "scatter3d") } function z() { var t, e, i, o, s, r, a, n, h, l, p, c, d, x; this.chart3d && this.is3d() && (t = this.renderer, a = this.options.chart.options3d, e = this.chart3d.get3dFrame(), i = this.plotLeft, o = this.plotLeft + this.plotWidth, s = this.plotTop, r = this.plotTop + this.plotHeight, a = a.depth, n = i - (e.left.visible ? e.left.size : 0), h = o + (e.right.visible ? e.right.size : 0), l = s - (e.top.visible ? e.top.size : 0), p = r + (e.bottom.visible ? e.bottom.size : 0), c = 0 - (e.front.visible ? e.front.size : 0), d = a + (e.back.visible ? e.back.size : 0), x = this.hasRendered ? "animate" : "attr", this.chart3d.frame3d = e, this.frameShapes || (this.frameShapes = { bottom: t.polyhedron().add(), top: t.polyhedron().add(), left: t.polyhedron().add(), right: t.polyhedron().add(), back: t.polyhedron().add(), front: t.polyhedron().add() }), this.frameShapes.bottom[x]({ class: "highcharts-3d-frame highcharts-3d-frame-bottom", zIndex: e.bottom.frontFacing ? -1e3 : 1e3, faces: [{ fill: y.color(e.bottom.color).brighten(.1).get(), vertexes: [{ x: n, y: p, z: c }, { x: h, y: p, z: c }, { x: h, y: p, z: d }, { x: n, y: p, z: d }], enabled: e.bottom.visible }, { fill: y.color(e.bottom.color).brighten(.1).get(), vertexes: [{ x: i, y: r, z: a }, { x: o, y: r, z: a }, { x: o, y: r, z: 0 }, { x: i, y: r, z: 0 }], enabled: e.bottom.visible }, { fill: y.color(e.bottom.color).brighten(-.1).get(), vertexes: [{ x: n, y: p, z: c }, { x: n, y: p, z: d }, { x: i, y: r, z: a }, { x: i, y: r, z: 0 }], enabled: e.bottom.visible && !e.left.visible }, { fill: y.color(e.bottom.color).brighten(-.1).get(), vertexes: [{ x: h, y: p, z: d }, { x: h, y: p, z: c }, { x: o, y: r, z: 0 }, { x: o, y: r, z: a }], enabled: e.bottom.visible && !e.right.visible }, { fill: y.color(e.bottom.color).get(), vertexes: [{ x: h, y: p, z: c }, { x: n, y: p, z: c }, { x: i, y: r, z: 0 }, { x: o, y: r, z: 0 }], enabled: e.bottom.visible && !e.front.visible }, { fill: y.color(e.bottom.color).get(), vertexes: [{ x: n, y: p, z: d }, { x: h, y: p, z: d }, { x: o, y: r, z: a }, { x: i, y: r, z: a }], enabled: e.bottom.visible && !e.back.visible }] }), this.frameShapes.top[x]({ class: "highcharts-3d-frame highcharts-3d-frame-top", zIndex: e.top.frontFacing ? -1e3 : 1e3, faces: [{ fill: y.color(e.top.color).brighten(.1).get(), vertexes: [{ x: n, y: l, z: d }, { x: h, y: l, z: d }, { x: h, y: l, z: c }, { x: n, y: l, z: c }], enabled: e.top.visible }, { fill: y.color(e.top.color).brighten(.1).get(), vertexes: [{ x: i, y: s, z: 0 }, { x: o, y: s, z: 0 }, { x: o, y: s, z: a }, { x: i, y: s, z: a }], enabled: e.top.visible }, { fill: y.color(e.top.color).brighten(-.1).get(), vertexes: [{ x: n, y: l, z: d }, { x: n, y: l, z: c }, { x: i, y: s, z: 0 }, { x: i, y: s, z: a }], enabled: e.top.visible && !e.left.visible }, { fill: y.color(e.top.color).brighten(-.1).get(), vertexes: [{ x: h, y: l, z: c }, { x: h, y: l, z: d }, { x: o, y: s, z: a }, { x: o, y: s, z: 0 }], enabled: e.top.visible && !e.right.visible }, { fill: y.color(e.top.color).get(), vertexes: [{ x: n, y: l, z: c }, { x: h, y: l, z: c }, { x: o, y: s, z: 0 }, { x: i, y: s, z: 0 }], enabled: e.top.visible && !e.front.visible }, { fill: y.color(e.top.color).get(), vertexes: [{ x: h, y: l, z: d }, { x: n, y: l, z: d }, { x: i, y: s, z: a }, { x: o, y: s, z: a }], enabled: e.top.visible && !e.back.visible }] }), this.frameShapes.left[x]({ class: "highcharts-3d-frame highcharts-3d-frame-left", zIndex: e.left.frontFacing ? -1e3 : 1e3, faces: [{ fill: y.color(e.left.color).brighten(.1).get(), vertexes: [{ x: n, y: p, z: c }, { x: i, y: r, z: 0 }, { x: i, y: r, z: a }, { x: n, y: p, z: d }], enabled: e.left.visible && !e.bottom.visible }, { fill: y.color(e.left.color).brighten(.1).get(), vertexes: [{ x: n, y: l, z: d }, { x: i, y: s, z: a }, { x: i, y: s, z: 0 }, { x: n, y: l, z: c }], enabled: e.left.visible && !e.top.visible }, { fill: y.color(e.left.color).brighten(-.1).get(), vertexes: [{ x: n, y: p, z: d }, { x: n, y: l, z: d }, { x: n, y: l, z: c }, { x: n, y: p, z: c }], enabled: e.left.visible }, { fill: y.color(e.left.color).brighten(-.1).get(), vertexes: [{ x: i, y: s, z: a }, { x: i, y: r, z: a }, { x: i, y: r, z: 0 }, { x: i, y: s, z: 0 }], enabled: e.left.visible }, { fill: y.color(e.left.color).get(), vertexes: [{ x: n, y: p, z: c }, { x: n, y: l, z: c }, { x: i, y: s, z: 0 }, { x: i, y: r, z: 0 }], enabled: e.left.visible && !e.front.visible }, { fill: y.color(e.left.color).get(), vertexes: [{ x: n, y: l, z: d }, { x: n, y: p, z: d }, { x: i, y: r, z: a }, { x: i, y: s, z: a }], enabled: e.left.visible && !e.back.visible }] }), this.frameShapes.right[x]({ class: "highcharts-3d-frame highcharts-3d-frame-right", zIndex: e.right.frontFacing ? -1e3 : 1e3, faces: [{ fill: y.color(e.right.color).brighten(.1).get(), vertexes: [{ x: h, y: p, z: d }, { x: o, y: r, z: a }, { x: o, y: r, z: 0 }, { x: h, y: p, z: c }], enabled: e.right.visible && !e.bottom.visible }, { fill: y.color(e.right.color).brighten(.1).get(), vertexes: [{ x: h, y: l, z: c }, { x: o, y: s, z: 0 }, { x: o, y: s, z: a }, { x: h, y: l, z: d }], enabled: e.right.visible && !e.top.visible }, { fill: y.color(e.right.color).brighten(-.1).get(), vertexes: [{ x: o, y: s, z: 0 }, { x: o, y: r, z: 0 }, { x: o, y: r, z: a }, { x: o, y: s, z: a }], enabled: e.right.visible }, { fill: y.color(e.right.color).brighten(-.1).get(), vertexes: [{ x: h, y: p, z: c }, { x: h, y: l, z: c }, { x: h, y: l, z: d }, { x: h, y: p, z: d }], enabled: e.right.visible }, { fill: y.color(e.right.color).get(), vertexes: [{ x: h, y: l, z: c }, { x: h, y: p, z: c }, { x: o, y: r, z: 0 }, { x: o, y: s, z: 0 }], enabled: e.right.visible && !e.front.visible }, { fill: y.color(e.right.color).get(), vertexes: [{ x: h, y: p, z: d }, { x: h, y: l, z: d }, { x: o, y: s, z: a }, { x: o, y: r, z: a }], enabled: e.right.visible && !e.back.visible }] }), this.frameShapes.back[x]({ class: "highcharts-3d-frame highcharts-3d-frame-back", zIndex: e.back.frontFacing ? -1e3 : 1e3, faces: [{ fill: y.color(e.back.color).brighten(.1).get(), vertexes: [{ x: h, y: p, z: d }, { x: n, y: p, z: d }, { x: i, y: r, z: a }, { x: o, y: r, z: a }], enabled: e.back.visible && !e.bottom.visible }, { fill: y.color(e.back.color).brighten(.1).get(), vertexes: [{ x: n, y: l, z: d }, { x: h, y: l, z: d }, { x: o, y: s, z: a }, { x: i, y: s, z: a }], enabled: e.back.visible && !e.top.visible }, { fill: y.color(e.back.color).brighten(-.1).get(), vertexes: [{ x: n, y: p, z: d }, { x: n, y: l, z: d }, { x: i, y: s, z: a }, { x: i, y: r, z: a }], enabled: e.back.visible && !e.left.visible }, { fill: y.color(e.back.color).brighten(-.1).get(), vertexes: [{ x: h, y: l, z: d }, { x: h, y: p, z: d }, { x: o, y: r, z: a }, { x: o, y: s, z: a }], enabled: e.back.visible && !e.right.visible }, { fill: y.color(e.back.color).get(), vertexes: [{ x: i, y: s, z: a }, { x: o, y: s, z: a }, { x: o, y: r, z: a }, { x: i, y: r, z: a }], enabled: e.back.visible }, { fill: y.color(e.back.color).get(), vertexes: [{ x: n, y: p, z: d }, { x: h, y: p, z: d }, { x: h, y: l, z: d }, { x: n, y: l, z: d }], enabled: e.back.visible }] }), this.frameShapes.front[x]({ class: "highcharts-3d-frame highcharts-3d-frame-front", zIndex: e.front.frontFacing ? -1e3 : 1e3, faces: [{ fill: y.color(e.front.color).brighten(.1).get(), vertexes: [{ x: n, y: p, z: c }, { x: h, y: p, z: c }, { x: o, y: r, z: 0 }, { x: i, y: r, z: 0 }], enabled: e.front.visible && !e.bottom.visible }, { fill: y.color(e.front.color).brighten(.1).get(), vertexes: [{ x: h, y: l, z: c }, { x: n, y: l, z: c }, { x: i, y: s, z: 0 }, { x: o, y: s, z: 0 }], enabled: e.front.visible && !e.top.visible }, { fill: y.color(e.front.color).brighten(-.1).get(), vertexes: [{ x: n, y: l, z: c }, { x: n, y: p, z: c }, { x: i, y: r, z: 0 }, { x: i, y: s, z: 0 }], enabled: e.front.visible && !e.left.visible }, { fill: y.color(e.front.color).brighten(-.1).get(), vertexes: [{ x: h, y: p, z: c }, { x: h, y: l, z: c }, { x: o, y: s, z: 0 }, { x: o, y: r, z: 0 }], enabled: e.front.visible && !e.right.visible }, { fill: y.color(e.front.color).get(), vertexes: [{ x: o, y: s, z: 0 }, { x: i, y: s, z: 0 }, { x: i, y: r, z: 0 }, { x: o, y: r, z: 0 }], enabled: e.front.visible }, { fill: y.color(e.front.color).get(), vertexes: [{ x: h, y: p, z: c }, { x: n, y: p, z: c }, { x: n, y: l, z: c }, { x: h, y: l, z: c }], enabled: e.front.visible }] })) } function b() { this.styledMode && (this.renderer.definition({ tagName: "style", textContent: ".highcharts-3d-top{filter: url(#highcharts-brighter)}\n.highcharts-3d-side{filter: url(#highcharts-darker)}\n" }), [{ name: "darker", slope: .6 }, { name: "brighter", slope: 1.4 }].forEach(function (t) { this.renderer.definition({ tagName: "filter", id: "highcharts-" + t.name, children: [{ tagName: "feComponentTransfer", children: [{ tagName: "feFuncR", type: "linear", slope: t.slope }, { tagName: "feFuncG", type: "linear", slope: t.slope }, { tagName: "feFuncB", type: "linear", slope: t.slope }] }] }) }, this)) } function M() { var e = this.options; this.is3d() && (e.series || []).forEach(function (t) { "scatter" === (t.type || e.chart.type || e.chart.defaultSeriesType) && (t.type = "scatter3d") }) } function A() { var t, e, i, o = this.options.chart.options3d; this.chart3d && this.is3d() && (o && (o.alpha = o.alpha % 360 + (0 <= o.alpha ? 0 : 360), o.beta = o.beta % 360 + (0 <= o.beta ? 0 : 360)), t = this.inverted, e = this.clipBox, i = this.margin, e[t ? "y" : "x"] = -(i[3] || 0), e[t ? "x" : "y"] = -(i[0] || 0), e[t ? "height" : "width"] = this.chartWidth + (i[3] || 0) + (i[1] || 0), e[t ? "width" : "height"] = this.chartHeight + (i[0] || 0) + (i[2] || 0), this.scale3d = 1, !0 === o.fitToPlot && (this.scale3d = this.chart3d.getScale(o.depth)), this.chart3d.frame3d = this.chart3d.get3dFrame()) } function P() { this.is3d() && (this.isDirtyBox = !0) } function S() { this.chart3d && this.is3d() && (this.chart3d.frame3d = this.chart3d.get3dFrame()) } function k() { this.chart3d || (this.chart3d = new c(this)) } function D(t) { return this.is3d() || t.apply(this, [].slice.call(arguments, 1)) } function C(t) { var e = this.series.length; if (this.is3d()) for (; e--;)(t = this.series[e]).translate(), t.render(); else t.call(this) } function L(t) { t.apply(this, [].slice.call(arguments, 1)), this.is3d() && (this.container.className += " highcharts-3d-chart") } function w(t) { this.frame3d = void 0, this.chart = t } return p = l = l || {}, w.prototype.get3dFrame = function () { var a = this.chart, t = a.options.chart.options3d, e = t.frame, i = a.plotLeft, o = a.plotLeft + a.plotWidth, s = a.plotTop, r = a.plotTop + a.plotHeight, n = t.depth, h = (x = function (t) { return .5 < (t = v(t, a)) ? 1 : t < -.5 ? -1 : 0 })([{ x: i, y: r, z: n }, { x: o, y: r, z: n }, { x: o, y: r, z: 0 }, { x: i, y: r, z: 0 }]), l = x([{ x: i, y: s, z: 0 }, { x: o, y: s, z: 0 }, { x: o, y: s, z: n }, { x: i, y: s, z: n }]), p = x([{ x: i, y: s, z: 0 }, { x: i, y: s, z: n }, { x: i, y: r, z: n }, { x: i, y: r, z: 0 }]), c = x([{ x: o, y: s, z: n }, { x: o, y: s, z: 0 }, { x: o, y: r, z: 0 }, { x: o, y: r, z: n }]), d = x([{ x: i, y: r, z: 0 }, { x: o, y: r, z: 0 }, { x: o, y: s, z: 0 }, { x: i, y: s, z: 0 }]), x = x([{ x: i, y: s, z: n }, { x: o, y: s, z: n }, { x: o, y: r, z: n }, { x: i, y: r, z: n }]), y = !1, f = !1, u = !1, z = !1; function b(t, e, i) { for (var o = ["size", "color", "visible"], s = {}, r = 0; r < o.length; r++)for (var a = o[r], n = 0; n < t.length; n++)if ("object" == typeof t[n]) { var h = t[n][a]; if (null != h) { s[a] = h; break } } return t = i, !0 === s.visible || !1 === s.visible ? t = s.visible : "auto" === s.visible && (t = 0 < e), { size: m(s.size, 1), color: m(s.color, "none"), frontFacing: 0 < e, visible: t } } return [].concat(a.xAxis, a.yAxis, a.zAxis).forEach(function (t) { t && (t.horiz ? t.opposite ? f = !0 : y = !0 : t.opposite ? z = !0 : u = !0) }), e = { axes: {}, bottom: b([e.bottom, e.top, e], h, y), top: b([e.top, e.bottom, e], l, f), left: b([e.left, e.right, e.side, e], p, u), right: b([e.right, e.left, e.side, e], c, z), back: b([e.back, e.front, e], x, !0), front: b([e.front, e.back, e], d, !1) }, "auto" === t.axisLabelPosition ? (t = [], (c = function (t, e) { return t.visible !== e.visible || t.visible && e.visible && t.frontFacing !== e.frontFacing })(e.left, e.front) && t.push({ y: (s + r) / 2, x: i, z: 0, xDir: { x: 1, y: 0, z: 0 } }), c(e.left, e.back) && t.push({ y: (s + r) / 2, x: i, z: n, xDir: { x: 0, y: 0, z: -1 } }), c(e.right, e.front) && t.push({ y: (s + r) / 2, x: o, z: 0, xDir: { x: 0, y: 0, z: 1 } }), c(e.right, e.back) && t.push({ y: (s + r) / 2, x: o, z: n, xDir: { x: -1, y: 0, z: 0 } }), h = [], c(e.bottom, e.front) && h.push({ x: (i + o) / 2, y: r, z: 0, xDir: { x: 1, y: 0, z: 0 } }), c(e.bottom, e.back) && h.push({ x: (i + o) / 2, y: r, z: n, xDir: { x: -1, y: 0, z: 0 } }), l = [], c(e.top, e.front) && l.push({ x: (i + o) / 2, y: s, z: 0, xDir: { x: 1, y: 0, z: 0 } }), c(e.top, e.back) && l.push({ x: (i + o) / 2, y: s, z: n, xDir: { x: -1, y: 0, z: 0 } }), p = [], c(e.bottom, e.left) && p.push({ z: (0 + n) / 2, y: r, x: i, xDir: { x: 0, y: 0, z: -1 } }), c(e.bottom, e.right) && p.push({ z: (0 + n) / 2, y: r, x: o, xDir: { x: 0, y: 0, z: 1 } }), r = [], c(e.top, e.left) && r.push({ z: (0 + n) / 2, y: s, x: i, xDir: { x: 0, y: 0, z: -1 } }), c(e.top, e.right) && r.push({ z: (0 + n) / 2, y: s, x: o, xDir: { x: 0, y: 0, z: 1 } }), i = function (t, e, i) { if (0 === t.length) return null; if (1 === t.length) return t[0]; for (var o = 0, s = g(t, a, !1), r = 1; r < s.length; r++)(i * s[r][e] > i * s[o][e] || i * s[r][e] == i * s[o][e] && s[r].z < s[o].z) && (o = r); return t[o] }, e.axes = { y: { left: i(t, "x", -1), right: i(t, "x", 1) }, x: { top: i(l, "y", -1), bottom: i(h, "y", 1) }, z: { top: i(r, "y", -1), bottom: i(p, "y", 1) } }) : e.axes = { y: { left: { x: i, z: 0, xDir: { x: 1, y: 0, z: 0 } }, right: { x: o, z: 0, xDir: { x: 0, y: 0, z: 1 } } }, x: { top: { y: s, z: 0, xDir: { x: 1, y: 0, z: 0 } }, bottom: { y: r, z: 0, xDir: { x: 1, y: 0, z: 0 } } }, z: { top: { x: u ? o : i, y: s, xDir: u ? { x: 0, y: 0, z: 1 } : { x: 0, y: 0, z: -1 } }, bottom: { x: u ? o : i, y: r, xDir: u ? { x: 0, y: 0, z: 1 } : { x: 0, y: 0, z: -1 } } } }, e }, w.prototype.getScale = function (t) { var e = this.chart, i = e.plotLeft, o = e.plotWidth + i, s = e.plotTop, r = e.plotHeight + s, a = i + e.plotWidth / 2, n = s + e.plotHeight / 2, h = Number.MAX_VALUE, l = -Number.MAX_VALUE, p = Number.MAX_VALUE, c = -Number.MAX_VALUE, d = 1, x = [{ x: i, y: s, z: 0 }, { x: i, y: s, z: t }]; return [0, 1].forEach(function (t) { x.push({ x: o, y: x[t].y, z: x[t].z }) }), [0, 1, 2, 3].forEach(function (t) { x.push({ x: x[t].x, y: r, z: x[t].z }) }), (x = g(x, e, !1)).forEach(function (t) { h = Math.min(h, t.x), l = Math.max(l, t.x), p = Math.min(p, t.y), c = Math.max(c, t.y) }), h < i && (d = Math.min(d, 1 - Math.abs((i + a) / (h + a)) % 1)), o < l && (d = Math.min(d, (o - a) / (l - a))), p < s && (d = p < 0 ? Math.min(d, (s + n) / (-p + s + n)) : Math.min(d, 1 - (s + n) / (p + n) % 1)), r < c && (d = Math.min(d, Math.abs((r - n) / (c - n)))), d }, c = w, p.Composition = c, p.defaultOptions = { chart: { options3d: { enabled: !1, alpha: 0, beta: 0, depth: 100, fitToPlot: !0, viewDistance: 25, axisLabelPosition: null, frame: { visible: "default", size: 1, bottom: {}, top: {}, left: {}, right: {}, back: {}, front: {} } } } }, p.compose = function (t, e) { var i = t.prototype; e = e.prototype, i.is3d = function () { return this.options.chart.options3d && this.options.chart.options3d.enabled }, i.propsRequireDirtyBox.push("chart.options3d"), i.propsRequireUpdateSeries.push("chart.options3d"), e.matrixSetter = function () { if (this.pos < 1 && (d(this.start) || d(this.end))) for (var t = this.start || [1, 0, 0, 1, 0, 0], e = this.end || [1, 0, 0, 1, 0, 0], i = [], o = 0; o < 6; o++)i.push(this.pos * e[o] + (1 - this.pos) * t[o]); else i = this.end; this.elem.attr(this.prop, i, null, !0) }, x(!0, n, p.defaultOptions), h(t, "init", k), h(t, "addSeries", u), h(t, "afterDrawChartBox", z), h(t, "afterGetContainer", b), h(t, "afterInit", M), h(t, "afterSetChartSize", A), h(t, "beforeRedraw", P), h(t, "beforeRender", S), f(y.Chart.prototype, "isInsidePlot", D), f(t, "renderSeries", C), f(t, "setClassName", L) }, l.compose(i, o), a.ZChartComposition.compose(i), e.compose(t), l }), e(t, "Core/Series/Series3D.js", [t["Core/Globals.js"], t["Extensions/Math3D.js"], t["Core/Utilities.js"]], function (t, e, i) { var a = e.perspective; e = i.addEvent; var n = i.pick; e(t.Series, "afterTranslate", function () { this.chart.is3d() && this.translate3dPoints() }), t.Series.prototype.translate3dPoints = function () { for (var t = this.chart, e = n(this.zAxis, t.options.zAxis[0]), i = [], o = 0; o < this.data.length; o++) { var s, r = this.data[o]; e && e.translate ? (s = e.logarithmic && e.val2lin ? e.val2lin(r.z) : r.z, r.plotZ = e.translate(s), r.isInside = !!r.isInside && (s >= e.min && s <= e.max)) : r.plotZ = 0, r.axisXpos = r.plotX, r.axisYpos = r.plotY, r.axisZpos = r.plotZ, i.push({ x: r.plotX, y: r.plotY, z: r.plotZ }) } for (t = a(i, t, !0), o = 0; o < this.data.length; o++)r = this.data[o], e = t[o], r.plotX = e.x, r.plotY = e.y, r.plotZ = e.z } }), e(t, "Series/Column3DSeries.js", [t["Core/Globals.js"], t["Extensions/Math3D.js"], t["Extensions/Stacking.js"], t["Core/Utilities.js"]], function (t, e, i, o) { function s(t) { var e = t.apply(this, [].slice.call(arguments, 1)); return this.chart.is3d && this.chart.is3d() && (e.stroke = this.options.edgeColor || e.fill, e["stroke-width"] = d(this.options.edgeWidth, 1)), e } function r(t, e, i) { var o = this.chart.is3d && this.chart.is3d(); o && (this.options.inactiveOtherPoints = !0), t.call(this, e, i), o && (this.options.inactiveOtherPoints = !1) } function a(t) { for (var e = [], i = 1; i < arguments.length; i++)e[i - 1] = arguments[i]; return this.series.chart.is3d() ? this.graphic && "g" !== this.graphic.element.nodeName : t.apply(this, e) } var c = e.perspective; e = o.addEvent; var d = o.pick; o = o.wrap; var n = t.Series, x = t.seriesTypes, h = t.svg; o(x.column.prototype, "translate", function (t) { t.apply(this, [].slice.call(arguments, 1)), this.chart.is3d() && this.translate3dShapes() }), o(n.prototype, "justifyDataLabel", function (t) { return !arguments[2].outside3dPlot && t.apply(this, [].slice.call(arguments, 1)) }), x.column.prototype.translate3dPoints = function () { }, x.column.prototype.translate3dShapes = function () { var e, r = this, a = r.chart, t = r.options, n = t.depth, h = (t.stacking ? t.stack || 0 : r.index) * (n + (t.groupZPadding || 1)), l = r.borderWidth % 2 ? .5 : 0; a.inverted && !r.yAxis.reversed && (l *= -1), !1 !== t.grouping && (h = 0), h += t.groupZPadding || 1, r.data.forEach(function (i) { var o, t, s; (i.outside3dPlot = null) !== i.y && (o = i.shapeArgs, t = i.tooltipPos, [["x", "width"], ["y", "height"]].forEach(function (t) { if ((s = o[t[0]] - l) < 0 && (o[t[1]] += o[t[0]] + l, o[t[0]] = -l, s = 0), s + o[t[1]] > r[t[0] + "Axis"].len && 0 !== o[t[1]] && (o[t[1]] = r[t[0] + "Axis"].len - o[t[0]]), 0 !== o[t[1]] && (o[t[0]] >= r[t[0] + "Axis"].len || o[t[0]] + o[t[1]] <= l)) { for (var e in o) o[e] = 0; i.outside3dPlot = !0 } }), "rect" === i.shapeType && (i.shapeType = "cuboid"), o.z = h, o.depth = n, o.insidePlotArea = !0, e = { x: o.x + o.width / 2, y: o.y, z: h + n / 2 }, a.inverted && (e.x = o.height, e.y = i.clientX), i.plot3d = c([e], a, !0, !1)[0], t = c([{ x: t[0], y: t[1], z: h + n / 2 }], a, !0, !1)[0], i.tooltipPos = [t.x, t.y]) }), r.z = h }, o(x.column.prototype, "animate", function (t) { var e, i, o, s; this.chart.is3d() ? (e = arguments[1], i = this.yAxis, s = (o = this).yAxis.reversed, h && (e ? o.data.forEach(function (t) { null !== t.y && (t.height = t.shapeArgs.height, t.shapey = t.shapeArgs.y, t.shapeArgs.height = 1, s || (t.shapeArgs.y = t.stackY ? t.plotY + i.translate(t.stackY) : t.plotY + (t.negative ? -t.height : t.height))) }) : (o.data.forEach(function (t) { null !== t.y && (t.shapeArgs.height = t.height, t.shapeArgs.y = t.shapey, t.graphic && t.graphic.animate(t.shapeArgs, o.options.animation)) }), this.drawDataLabels()))) : t.apply(this, [].slice.call(arguments, 1)) }), o(x.column.prototype, "plotGroup", function (t, e, i, o, s, r) { return "dataLabelsGroup" !== e && this.chart.is3d() && (this[e] && delete this[e], r && (this.chart.columnGroup || (this.chart.columnGroup = this.chart.renderer.g("columnGroup").add(r)), this[e] = this.chart.columnGroup, this.chart.columnGroup.attr(this.getPlotBox()), this[e].survive = !0, "group" === e || "markerGroup" === e)) && (o = "visible"), t.apply(this, Array.prototype.slice.call(arguments, 1)) }), o(x.column.prototype, "setVisible", function (t, e) { var i, o = this; o.chart.is3d() && o.data.forEach(function (t) { i = (t.visible = t.options.visible = e = void 0 === e ? !d(o.visible, t.visible) : e) ? "visible" : "hidden", o.options.data[o.data.indexOf(t)] = t.options, t.graphic && t.graphic.attr({ visibility: i }) }), t.apply(this, Array.prototype.slice.call(arguments, 1)) }), x.column.prototype.handle3dGrouping = !0, e(n, "afterInit", function () { if (this.chart.is3d() && this.handle3dGrouping) { var t = this.options, e = t.grouping, i = t.stacking, o = d(this.yAxis.options.reversedStacks, !0), s = 0; if (void 0 === e || e) { for (r = this.chart, a = i, h = r.series, l = {}, p = 1, h.forEach(function (t) { n = d(t.options.stack, a ? 0 : h.length - 1 - t.index), l[n] ? l[n].series.push(t) : (l[n] = { series: [t], position: p }, p++) }), l.totalStacks = p + 1, e = l, s = t.stack || 0, i = 0; i < e[s].series.length && e[s].series[i] !== this; i++); s = 10 * (e.totalStacks - e[s].position) + (o ? i : -i), this.xAxis.reversed || (s = 10 * e.totalStacks - s) } t.depth = t.depth || 25, this.z = this.z || 0, t.zIndex = s } var r, a, n, h, l, p }), o(x.column.prototype, "pointAttribs", s), o(x.column.prototype, "setState", r), o(x.column.prototype.pointClass.prototype, "hasNewShapeType", a), x.columnrange && (o(x.columnrange.prototype, "pointAttribs", s), o(x.columnrange.prototype, "setState", r), o(x.columnrange.prototype.pointClass.prototype, "hasNewShapeType", a), x.columnrange.prototype.plotGroup = x.column.prototype.plotGroup, x.columnrange.prototype.setVisible = x.column.prototype.setVisible), o(n.prototype, "alignDataLabel", function (t, e, i, o, s) { var r, a, n, h, l = this.chart; o.outside3dPlot = e.outside3dPlot, l.is3d() && this.is("column") && (h = this.options, r = d(o.inside, !!this.options.stacking), a = l.options.chart.options3d, n = e.pointWidth / 2 || 0, h = { x: s.x + n, y: s.y, z: this.z + h.depth / 2 }, l.inverted && (r && (s.width = 0, h.x += e.shapeArgs.height / 2), 90 <= a.alpha && a.alpha <= 270 && (h.y += e.shapeArgs.width)), h = c([h], l, !0, !1)[0], s.x = h.x - n, s.y = e.outside3dPlot ? -9e9 : h.y), t.apply(this, [].slice.call(arguments, 1)) }), o(i.prototype, "getStackBox", function (t, e, i, o, s, r, a, n) { var h, l, p = t.apply(this, [].slice.call(arguments, 1)); return e.is3d() && i.base && (l = +i.base.split(",")[0], h = e.series[l], l = e.options.chart.options3d, h && h instanceof x.column && (h = { x: p.x + (e.inverted ? a : r / 2), y: p.y, z: h.options.depth / 2 }, e.inverted && (p.width = 0, 90 <= l.alpha && l.alpha <= 270 && (h.y += r)), h = c([h], e, !0, !1)[0], p.x = h.x - r / 2, p.y = h.y)), p }) }), e(t, "Series/Pie3DSeries.js", [t["Core/Globals.js"], t["Core/Utilities.js"]], function (t, e) { var a = e.pick; e = e.wrap; var h = t.deg2rad, i = t.seriesTypes, n = t.svg; e(i.pie.prototype, "translate", function (t) { var i, o, s, e, r, a, n; t.apply(this, [].slice.call(arguments, 1)), this.chart.is3d() && (o = (i = this).options, s = o.depth || 0, e = i.chart.options.chart.options3d, r = e.alpha, a = e.beta, n = o.stacking ? (o.stack || 0) * s : i._i * s, n += s / 2, !1 !== o.grouping && (n = 0), i.data.forEach(function (t) { var e = t.shapeArgs; t.shapeType = "arc3d", e.z = n, e.depth = .75 * s, e.alpha = r, e.beta = a, e.center = i.center, e = (e.end + e.start) / 2, t.slicedTranslation = { translateX: Math.round(Math.cos(e) * o.slicedOffset * Math.cos(r * h)), translateY: Math.round(Math.sin(e) * o.slicedOffset * Math.cos(r * h)) } })) }), e(i.pie.prototype.pointClass.prototype, "haloPath", function (t) { var e = arguments; return this.series.chart.is3d() ? [] : t.call(this, e[1]) }), e(i.pie.prototype, "pointAttribs", function (t, e, i) { return t = t.call(this, e, i), i = this.options, this.chart.is3d() && !this.chart.styledMode && (t.stroke = i.edgeColor || e.color || this.color, t["stroke-width"] = a(i.edgeWidth, 1)), t }), e(i.pie.prototype, "drawDataLabels", function (t) { var n; this.chart.is3d() && (n = this.chart.options.chart.options3d, this.data.forEach(function (t) { var e = t.shapeArgs, i = e.r, o = (e.start + e.end) / 2, s = (t = t.labelPosition).connectorPosition, r = -i * (1 - Math.cos((e.alpha || n.alpha) * h)) * Math.sin(o), a = i * (Math.cos((e.beta || n.beta) * h) - 1) * Math.cos(o);[t.natural, s.breakAt, s.touchingSliceAt].forEach(function (t) { t.x += a, t.y += r }) })), t.apply(this, [].slice.call(arguments, 1)) }), e(i.pie.prototype, "addPoint", function (t) { t.apply(this, [].slice.call(arguments, 1)), this.chart.is3d() && this.update(this.userOptions, !0) }), e(i.pie.prototype, "animate", function (t) { var e, i, o, s, r; this.chart.is3d() ? (e = arguments[1], i = this.options.animation, o = this.center, s = this.group, r = this.markerGroup, n && (!0 === i && (i = {}), e ? (s.oldtranslateX = a(s.oldtranslateX, s.translateX), s.oldtranslateY = a(s.oldtranslateY, s.translateY), e = { translateX: o[0], translateY: o[1], scaleX: .001, scaleY: .001 }, s.attr(e), r && (r.attrSetters = s.attrSetters, r.attr(e))) : (e = { translateX: s.oldtranslateX, translateY: s.oldtranslateY, scaleX: 1, scaleY: 1 }, s.animate(e, i), r && r.animate(e, i)))) : t.apply(this, [].slice.call(arguments, 1)) }) }), e(t, "Series/Scatter3DSeries.js", [t["Core/Globals.js"], t["Extensions/Math3D.js"], t["Core/Series/Point.js"], t["Core/Utilities.js"]], function (t, e, i, o) { var s = e.pointCameraDistance; e = o.seriesType; var r = t.seriesTypes; e("scatter3d", "scatter", { tooltip: { pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>z: <b>{point.z}</b><br/>" } }, { pointAttribs: function (t) { var e = r.scatter.prototype.pointAttribs.apply(this, arguments); return this.chart.is3d() && t && (e.zIndex = s(t, this.chart)), e }, axisTypes: ["xAxis", "yAxis", "zAxis"], pointArrayMap: ["x", "y", "z"], parallelArrays: ["x", "y", "z"], directTouch: !0 }, { applyOptions: function () { return i.prototype.applyOptions.apply(this, arguments), void 0 === this.z && (this.z = 0), this } }) }), e(t, "Core/Axis/VMLAxis3D.js", [t["Core/Utilities.js"]], function (t) { var e = t.addEvent, i = function (t) { this.axis = t }; return o.compose = function (t) { t.keepProps.push("vml"), e(t, "init", o.onInit), e(t, "render", o.onRender) }, o.onInit = function () { this.vml || (this.vml = new i(this)) }, o.onRender = function () { var t = this.vml; t.sideFrame && (t.sideFrame.css({ zIndex: 0 }), t.sideFrame.front.attr({ fill: t.sideFrame.color })), t.bottomFrame && (t.bottomFrame.css({ zIndex: 1 }), t.bottomFrame.front.attr({ fill: t.bottomFrame.color })), t.backFrame && (t.backFrame.css({ zIndex: 0 }), t.backFrame.front.attr({ fill: t.backFrame.color })) }, o; function o() { } }), e(t, "Core/Renderer/VML/VMLRenderer3D.js", [t["Core/Axis/Axis.js"], t["Core/Globals.js"], t["Core/Renderer/SVG/SVGRenderer.js"], t["Core/Utilities.js"], t["Core/Axis/VMLAxis3D.js"]], function (t, e, i, o, s) { o = o.setOptions; var r = e.VMLRenderer; r && (o({ animate: !1 }), r.prototype.face3d = i.prototype.face3d, r.prototype.polyhedron = i.prototype.polyhedron, r.prototype.elements3d = i.prototype.elements3d, r.prototype.element3d = i.prototype.element3d, r.prototype.cuboid = i.prototype.cuboid, r.prototype.cuboidPath = i.prototype.cuboidPath, r.prototype.toLinePath = i.prototype.toLinePath, r.prototype.toLineSegments = i.prototype.toLineSegments, r.prototype.arc3d = function (t) { return (t = i.prototype.arc3d.call(this, t)).css({ zIndex: t.zIndex }), t }, e.VMLRenderer.prototype.arc3dPath = i.prototype.arc3dPath, s.compose(t)) }), e(t, "masters/highcharts-3d.src.js", [], function () { }) });