!function (e) { "object" == typeof module && module.exports ? module.exports = e.default = e : "function" == typeof define && define.amd ? define("highcharts/highcharts-more", ["highcharts"], function (t) { return e(t), e.Highcharts = t, e }) : e("undefined" != typeof Highcharts ? Highcharts : void 0) }(function (t) { function e(t, e, i, o) { t.hasOwnProperty(e) || (t[e] = o.apply(null, i)) } e(t = t ? t._modules : {}, "Extensions/Pane.js", [t["Core/Chart/Chart.js"], t["Core/Globals.js"], t["Core/Pointer.js"], t["Core/Utilities.js"], t["Mixins/CenteredSeries.js"]], function (t, e, i, o, s) { function r(t, e, i) { return Math.sqrt(Math.pow(t - i[0], 2) + Math.pow(e - i[1], 2)) <= i[2] / 2 } var a = o.addEvent, n = o.extend, h = o.merge, l = o.pick, p = o.splat; function d(t, e) { this.options = this.chart = this.center = this.background = void 0, this.coll = "pane", this.defaultOptions = { center: ["50%", "50%"], size: "85%", innerSize: "0%", startAngle: 0 }, this.defaultBackgroundOptions = { shape: "circle", borderWidth: 1, borderColor: "#cccccc", backgroundColor: { linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 }, stops: [[0, "#ffffff"], [1, "#e6e6e6"]] }, from: -Number.MAX_VALUE, innerRadius: 0, to: Number.MAX_VALUE, outerRadius: "105%" }, this.init(t, e) } return t.prototype.collectionsWithUpdate.push("pane"), d.prototype.init = function (t, e) { this.chart = e, this.background = [], e.pane.push(this), this.setOptions(t) }, d.prototype.setOptions = function (t) { this.options = h(this.defaultOptions, this.chart.angular ? { background: {} } : void 0, t) }, d.prototype.render = function () { var t = this.options, e = this.options.background, i = this.chart.renderer; if (this.group || (this.group = i.g("pane-group").attr({ zIndex: t.zIndex || 0 }).add()), this.updateCenter(), e) for (e = p(e), t = Math.max(e.length, this.background.length || 0), i = 0; i < t; i++)e[i] && this.axis ? this.renderBackground(h(this.defaultBackgroundOptions, e[i]), i) : this.background[i] && (this.background[i] = this.background[i].destroy(), this.background.splice(i, 1)) }, d.prototype.renderBackground = function (t, e) { var i = "animate", o = { class: "highcharts-pane " + (t.className || "") }; this.chart.styledMode || n(o, { fill: t.backgroundColor, stroke: t.borderColor, "stroke-width": t.borderWidth }), this.background[e] || (this.background[e] = this.chart.renderer.path().add(this.group), i = "attr"), this.background[e][i]({ d: this.axis.getPlotBandPath(t.from, t.to, t) }).attr(o) }, d.prototype.updateCenter = function (t) { this.center = (t || this.axis || {}).center = s.getCenter.call(this) }, d.prototype.update = function (t, e) { h(!0, this.options, t), h(!0, this.chart.options.pane, t), this.setOptions(this.options), this.render(), this.chart.axes.forEach(function (t) { t.pane === this && (t.pane = null, t.update({}, e)) }, this) }, o = d, e.Chart.prototype.getHoverPane = function (o) { var s, a = this; return o && a.pane.forEach(function (t) { var e = o.chartX - a.plotLeft, i = o.chartY - a.plotTop; r(a.inverted ? i : e, a.inverted ? e : i, t.center) && (s = t) }), s }, a(t, "afterIsInsidePlot", function (e) { this.polar && (e.isInsidePlot = this.pane.some(function (t) { return r(e.x, e.y, t.center) })) }), a(i, "beforeGetHoverData", function (e) { var i = this.chart; i.polar && (i.hoverPane = i.getHoverPane(e), e.filter = function (t) { return t.visible && !(!e.shared && t.directTouch) && l(t.options.enableMouseTracking, !0) && (!i.hoverPane || t.xAxis.pane === i.hoverPane) }) }), a(i, "afterGetHoverData", function (t) { var e = this.chart; t.hoverPoint && t.hoverPoint.plotX && t.hoverPoint.plotY && e.hoverPane && !r(t.hoverPoint.plotX, t.hoverPoint.plotY, e.hoverPane.center) && (t.hoverPoint = void 0) }), e.Pane = o, e.Pane }), e(t, "Core/Axis/HiddenAxis.js", [], function () { return t.init = function (t) { t.getOffset = function () { }, t.redraw = function () { this.isDirty = !1 }, t.render = function () { this.isDirty = !1 }, t.createLabelCollector = function () { return function () { } }, t.setScale = function () { }, t.setCategories = function () { }, t.setTitle = function () { }, t.isHidden = !0 }, t; function t() { } }), e(t, "Core/Axis/RadialAxis.js", [t["Core/Axis/Axis.js"], t["Core/Axis/Tick.js"], t["Core/Axis/HiddenAxis.js"], t["Core/Utilities.js"]], function (t, e, d, i) { var o = i.addEvent, s = i.correctFloat, n = i.defined, a = i.extend, r = i.fireEvent, c = i.merge, m = i.pick, y = i.relativeLength, h = i.wrap; function u() { } return u.init = function (e) { var i = t.prototype; e.setOptions = function (t) { (t = this.options = c(e.constructor.defaultOptions, this.defaultPolarOptions, t)).plotBands || (t.plotBands = []), r(this, "afterSetOptions") }, e.getOffset = function () { i.getOffset.call(this), this.chart.axisOffset[this.side] = 0 }, e.getLinePath = function (t, e, i) { t = this.pane.center; var o = this.chart, s = m(e, t[2] / 2 - this.offset); return void 0 === i && (i = this.horiz ? 0 : this.center && -this.center[3] / 2), i && (s += i), this.isCircular || void 0 !== e ? ((e = this.chart.renderer.symbols.arc(this.left + t[0], this.top + t[1], s, s, { start: this.startAngleRad, end: this.endAngleRad, open: !0, innerR: 0 })).xBounds = [this.left + t[0]], e.yBounds = [this.top + t[1] - s]) : (e = this.postTranslate(this.angleRad, s), e = [["M", this.center[0] + o.plotLeft, this.center[1] + o.plotTop], ["L", e.x, e.y]]), e }, e.setAxisTranslation = function () { i.setAxisTranslation.call(this), this.center && (this.transA = this.isCircular ? (this.endAngleRad - this.startAngleRad) / (this.max - this.min || 1) : (this.center[2] - this.center[3]) / 2 / (this.max - this.min || 1), this.minPixelPadding = this.isXAxis ? this.transA * this.minPointOffset : 0) }, e.beforeSetTickPositions = function () { this.autoConnect = this.isCircular && void 0 === m(this.userMax, this.options.max) && s(this.endAngleRad - this.startAngleRad) === s(2 * Math.PI), !this.isCircular && this.chart.inverted && this.max++, this.autoConnect && (this.max += (this.categories ? 1 : this.pointRange) || this.closestPointRange || 0) }, e.setAxisSize = function () { var t, e; i.setAxisSize.call(this), this.isRadial && (this.pane.updateCenter(this), t = this.center = a([], this.pane.center), this.isCircular ? this.sector = this.endAngleRad - this.startAngleRad : (e = this.postTranslate(this.angleRad, t[3] / 2), t[0] = e.x - this.chart.plotLeft, t[1] = e.y - this.chart.plotTop), this.len = this.width = this.height = (t[2] - t[3]) * m(this.sector, 1) / 2) }, e.getPosition = function (t, e) { return t = this.translate(t), this.postTranslate(this.isCircular ? t : this.angleRad, m(this.isCircular ? e : t < 0 ? 0 : t, this.center[2] / 2) - this.offset) }, e.postTranslate = function (t, e) { var i = this.chart, o = this.center; return t = this.startAngleRad + t, { x: i.plotLeft + o[0] + Math.cos(t) * e, y: i.plotTop + o[1] + Math.sin(t) * e } }, e.getPlotBandPath = function (t, e, i) { var o, s = function (t) { if ("string" != typeof t) return t; var e = parseInt(t, 10); return l.test(t) && (e = e * n / 100), e }, a = this.center, r = this.startAngleRad, n = a[2] / 2, h = Math.min(this.offset, 0), l = /%$/, p = this.isCircular, d = m(s(i.outerRadius), n), c = s(i.innerRadius), s = m(s(i.thickness), 10); return "polygon" === this.options.gridLineInterpolation ? h = this.getPlotLinePath({ value: t }).concat(this.getPlotLinePath({ value: e, reverse: !0 })) : (t = Math.max(t, this.min), e = Math.min(e, this.max), t = this.translate(t), e = this.translate(e), p || (d = t || 0, c = e || 0), "circle" !== i.shape && p ? (i = r + (t || 0), r += e || 0) : (i = -Math.PI / 2, r = 1.5 * Math.PI, o = !0), d -= h, h = this.chart.renderer.symbols.arc(this.left + a[0], this.top + a[1], d, d, { start: Math.min(i, r), end: Math.max(i, r), innerR: m(c, d - (s - h)), open: o }), p && (p = (r + i) / 2, o = this.left + a[0] + a[2] / 2 * Math.cos(p), h.xBounds = p > -Math.PI / 2 && p < Math.PI / 2 ? [o, this.chart.plotWidth] : [0, o], h.yBounds = [this.top + a[1] + a[2] / 2 * Math.sin(p)], h.yBounds[0] += p > -Math.PI && p < 0 || p > Math.PI ? -10 : 10)), h }, e.getCrosshairPosition = function (t, e, i) { var o, s, a = t.value, r = this.pane.center; return this.isCircular ? (n(a) ? !t.point || (o = t.point.shapeArgs || {}).start && (a = this.chart.inverted ? this.translate(t.point.rectPlotY, !0) : t.point.x) : (o = t.chartX || 0, s = t.chartY || 0, a = this.translate(Math.atan2(s - i, o - e) - this.startAngleRad, !0)), o = (t = this.getPosition(a)).x, s = t.y) : (n(a) || (o = t.chartX, s = t.chartY), n(o) && n(s) && (i = r[1] + this.chart.plotTop, a = this.translate(Math.min(Math.sqrt(Math.pow(o - e, 2) + Math.pow(s - i, 2)), r[2] / 2) - r[3] / 2, !0))), [a, o || 0, s || 0] }, e.getPlotLinePath = function (t) { var e, i = this, o = i.pane.center, s = i.chart, a = s.inverted, r = t.value, n = t.reverse, h = i.getPosition(r), l = (d = i.pane.options.background ? i.pane.options.background[0] || i.pane.options.background : {}).innerRadius || "0%", p = d.outerRadius || "100%", d = o[0] + s.plotLeft, c = o[1] + s.plotTop, u = h.x, g = h.y, f = i.height, h = o[3] / 2; if (t.isCrosshair && (r = (g = this.getCrosshairPosition(t, d, c))[0], u = g[1], g = g[2]), i.isCircular) r = Math.sqrt(Math.pow(u - d, 2) + Math.pow(g - c, 2)), n = "string" == typeof l ? y(l, 1) : l / r, s = "string" == typeof p ? y(p, 1) : p / r, o && h && (n < (r = h / r) && (n = r), s < r && (s = r)), o = [["M", d + n * (u - d), c - n * (c - g)], ["L", u - (1 - s) * (u - d), g + (1 - s) * (c - g)]]; else if ((r = i.translate(r)) && (r < 0 || f < r) && (r = 0), "circle" === i.options.gridLineInterpolation) o = i.getLinePath(0, r, h); else if (o = [], s[a ? "yAxis" : "xAxis"].forEach(function (t) { t.pane === i.pane && (e = t) }), e) for (d = e.tickPositions, e.autoConnect && (d = d.concat([d[0]])), n && (d = d.slice().reverse()), r && (r += h), u = 0; u < d.length; u++)c = e.getPosition(d[u], r), o.push(u ? ["L", c.x, c.y] : ["M", c.x, c.y]); return o }, e.getTitlePosition = function () { var t = this.center, e = this.chart, i = this.options.title; return { x: e.plotLeft + t[0] + (i.x || 0), y: e.plotTop + t[1] - { high: .5, middle: .25, low: 0 }[i.align] * t[2] + (i.y || 0) } }, e.createLabelCollector = function () { var e = this; return function () { if (e.isRadial && e.tickPositions && !0 !== e.options.labels.allowOverlap) return e.tickPositions.map(function (t) { return e.ticks[t] && e.ticks[t].label }).filter(function (t) { return !!t }) } } }, u.compose = function (p, t) { o(p, "init", function (t) { var e, i = this.chart, o = i.inverted, s = i.angular, a = i.polar, r = this.isXAxis, n = this.coll, h = s && r, l = i.options; t = t.userOptions.pane || 0, t = this.pane = i.pane && i.pane[t], "colorAxis" === n ? this.isRadial = !1 : (s ? (h ? d.init(this) : u.init(this), (e = !r) && (this.defaultPolarOptions = u.defaultRadialGaugeOptions)) : a && (u.init(this), this.defaultPolarOptions = (e = this.horiz) ? u.defaultCircularOptions : c("xAxis" === n ? p.defaultOptions : p.defaultYAxisOptions, u.defaultRadialOptions), o && "yAxis" === n && (this.defaultPolarOptions.stackLabels = p.defaultYAxisOptions.stackLabels)), s || a ? (this.isRadial = !0, l.chart.zoomType = null, this.labelCollector || (this.labelCollector = this.createLabelCollector()), this.labelCollector && i.labelCollectors.push(this.labelCollector)) : this.isRadial = !1, t && e && (t.axis = this), this.isCircular = e) }), o(p, "afterInit", function () { var t = this.chart, e = this.options, i = this.pane, o = i && i.options; t.angular && this.isXAxis || !i || !t.angular && !t.polar || (this.angleRad = (e.angle || 0) * Math.PI / 180, this.startAngleRad = (o.startAngle - 90) * Math.PI / 180, this.endAngleRad = (m(o.endAngle, o.startAngle + 360) - 90) * Math.PI / 180, this.offset = e.offset || 0) }), o(p, "autoLabelAlign", function (t) { this.isRadial && (t.align = void 0, t.preventDefault()) }), o(p, "destroy", function () { var t; this.chart && this.chart.labelCollectors && 0 <= (t = this.labelCollector ? this.chart.labelCollectors.indexOf(this.labelCollector) : -1) && this.chart.labelCollectors.splice(t, 1) }), o(p, "initialAxisTranslation", function () { this.isRadial && this.beforeSetTickPositions() }), o(t, "afterGetPosition", function (t) { this.axis.getPosition && a(t.pos, this.axis.getPosition(this.pos)) }), o(t, "afterGetLabelPosition", function (t) { var e, i, o, s, a, r, n, h, l, p, d, c, u, g, f = this.axis, b = this.label; b && (e = b.getBBox(), o = (i = f.options.labels).y, s = 20, a = i.align, r = (f.translate(this.pos) + f.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360, h = "end", p = l = (n = Math.round(r)) < 0 ? n + 360 : n, c = d = 0, u = null === i.y ? .3 * -e.height : 0, f.isRadial && (g = f.getPosition(this.pos, f.center[2] / 2 + y(m(i.distance, -25), f.center[2] / 2, -f.center[2] / 2)), "auto" === i.rotation ? b.attr({ rotation: r }) : null === o && (o = f.chart.renderer.fontMetrics(b.styles && b.styles.fontSize).b - e.height / 2), null === a && (a = f.isCircular ? (e.width > f.len * f.tickInterval / (f.max - f.min) && (s = 0), s < r && r < 180 - s ? "left" : 180 + s < r && r < 360 - s ? "right" : "center") : "center", b.attr({ align: a })), "auto" === a && 2 === f.tickPositions.length && f.isCircular && (90 < l && l < 180 ? l = 180 - l : 270 < l && l <= 360 && (l = 540 - l), 180 < p && p <= 360 && (p = 360 - p), f.pane.options.startAngle !== n && f.pane.options.startAngle !== n + 360 && f.pane.options.startAngle !== n - 360 || (h = "start"), a = 70 < p && p < 110 ? "center" : -90 <= n && n <= 90 || -360 <= n && n <= -270 || 270 <= n && n <= 360 ? "start" === h ? "right" : "left" : "start" === h ? "left" : "right", l < 15 || 180 <= l && l < 195 ? d = .3 * e.height : 15 <= l && l <= 35 ? d = "start" === h ? 0 : .75 * e.height : 195 <= l && l <= 215 ? d = "start" === h ? .75 * e.height : 0 : 35 < l && l <= 90 ? d = "start" === h ? .25 * -e.height : e.height : 215 < l && l <= 270 && (d = "start" === h ? e.height : .25 * -e.height), p < 15 ? c = "start" === h ? .15 * -e.height : .15 * e.height : 165 < p && p <= 180 && (c = "start" === h ? .15 * e.height : .15 * -e.height), b.attr({ align: a }), b.translate(c, d + u)), t.pos.x = g.x + i.x, t.pos.y = g.y + o)) }), h(t.prototype, "getMarkPath", function (t, e, i, o, s, a, r) { var n = this.axis; return e = n.isRadial ? ["M", e, i, "L", (t = n.getPosition(this.pos, n.center[2] / 2 + o)).x, t.y] : t.call(this, e, i, o, s, a, r) }) }, u.defaultCircularOptions = { gridLineWidth: 1, labels: { align: null, distance: 15, x: 0, y: null, style: { textOverflow: "none" } }, maxPadding: 0, minPadding: 0, showLastLabel: !1, tickLength: 0 }, u.defaultRadialGaugeOptions = { labels: { align: "center", x: 0, y: null }, minorGridLineWidth: 0, minorTickInterval: "auto", minorTickLength: 10, minorTickPosition: "inside", minorTickWidth: 1, tickLength: 10, tickPosition: "inside", tickWidth: 2, title: { rotation: 0 }, zIndex: 2 }, u.defaultRadialOptions = { gridLineInterpolation: "circle", gridLineWidth: 1, labels: { align: "right", x: -3, y: -2 }, showLastLabel: !1, title: { x: 4, text: null, rotation: 90 } }, (i = u).compose(t, e), i }), e(t, "Series/AreaRangeSeries.js", [t["Core/Globals.js"], t["Core/Series/Point.js"], t["Core/Utilities.js"]], function (t, e, i) { var o = i.defined, p = i.extend, d = i.isArray, s = i.isNumber, u = i.pick; i = i.seriesType; var g = t.seriesTypes, c = t.Series.prototype, a = e.prototype; i("arearange", "area", { lineWidth: 1, threshold: null, tooltip: { pointFormat: '<span style="color:{series.color}">●</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>' }, trackByArea: !0, dataLabels: { align: void 0, verticalAlign: void 0, xLow: 0, xHigh: 0, yLow: 0, yHigh: 0 } }, { pointArrayMap: ["low", "high"], pointValKey: "low", deferTranslatePolar: !0, toYData: function (t) { return [t.low, t.high] }, highToXY: function (t) { var e = this.chart, i = this.xAxis.postTranslate(t.rectPlotX, this.yAxis.len - t.plotHigh); t.plotHighX = i.x - e.plotLeft, t.plotHigh = i.y - e.plotTop, t.plotLowX = t.plotX }, translate: function () { var o = this, s = o.yAxis, a = !!o.modifyValue; g.area.prototype.translate.apply(o), o.points.forEach(function (t) { var e = t.high, i = t.plotY; t.isNull ? t.plotY = null : (t.plotLow = i, t.plotHigh = s.translate(a ? o.modifyValue(e, t) : e, 0, 1, 0, 1), a && (t.yBottom = t.plotHigh)) }), this.chart.polar && this.points.forEach(function (t) { o.highToXY(t), t.tooltipPos = [(t.plotHighX + t.plotLowX) / 2, (t.plotHigh + t.plotLow) / 2] }) }, getGraphPath: function (t) { for (var e = [], i = [], o = g.area.prototype.getGraphPath, s = this.options, a = this.chart.polar, r = a && !1 !== s.connectEnds, n = s.connectNulls, h = s.step, l = (t = t || this.points).length; l--;) { var p = t[l], d = a ? { plotX: p.rectPlotX, plotY: p.yBottom, doCurve: !1 } : { plotX: p.plotX, plotY: p.plotY, doCurve: !1 }; p.isNull || r || n || t[l + 1] && !t[l + 1].isNull || i.push(d); var c = { polarPlotY: p.polarPlotY, rectPlotX: p.rectPlotX, yBottom: p.yBottom, plotX: u(p.plotHighX, p.plotX), plotY: p.plotHigh, isNull: p.isNull }; i.push(c), e.push(c), p.isNull || r || n || t[l - 1] && !t[l - 1].isNull || i.push(d) } return t = o.call(this, t), h && (!0 === h && (h = "left"), s.step = { left: "right", center: "center", right: "left" }[h]), e = o.call(this, e), i = o.call(this, i), s.step = h, s = [].concat(t, e), !this.chart.polar && i[0] && "M" === i[0][0] && (i[0] = ["L", i[0][1], i[0][2]]), this.graphPath = s, this.areaPath = t.concat(i), s.isArea = !0, s.xMap = t.xMap, this.areaPath.xMap = t.xMap, s }, drawDataLabels: function () { var t, e, i, o, s, a = this.points, r = a.length, n = [], h = this.options.dataLabels, l = this.chart.inverted; if (d(h) ? o = 1 < h.length ? (i = h[0], h[1]) : (i = h[0], { enabled: !1 }) : ((i = p({}, h)).x = h.xHigh, i.y = h.yHigh, (o = p({}, h)).x = h.xLow, o.y = h.yLow), i.enabled || this._hasPointLabels) { for (t = r; t--;) { (e = a[t]) && (s = i.inside ? e.plotHigh < e.plotLow : e.plotHigh > e.plotLow, e.y = e.high, e._plotY = e.plotY, e.plotY = e.plotHigh, n[t] = e.dataLabel, e.dataLabel = e.dataLabelUpper, e.below = s, l ? i.align || (i.align = s ? "right" : "left") : i.verticalAlign || (i.verticalAlign = s ? "top" : "bottom")) } for (this.options.dataLabels = i, c.drawDataLabels && c.drawDataLabels.apply(this, arguments), t = r; t--;)(e = a[t]) && (e.dataLabelUpper = e.dataLabel, e.dataLabel = n[t], delete e.dataLabels, e.y = e.low, e.plotY = e._plotY) } if (o.enabled || this._hasPointLabels) { for (t = r; t--;)(e = a[t]) && (s = o.inside ? e.plotHigh < e.plotLow : e.plotHigh > e.plotLow, e.below = !s, l ? o.align || (o.align = s ? "left" : "right") : o.verticalAlign || (o.verticalAlign = s ? "bottom" : "top")); this.options.dataLabels = o, c.drawDataLabels && c.drawDataLabels.apply(this, arguments) } if (i.enabled) for (t = r; t--;)(e = a[t]) && (e.dataLabels = [e.dataLabelUpper, e.dataLabel].filter(function (t) { return !!t })); this.options.dataLabels = h }, alignDataLabel: function () { g.column.prototype.alignDataLabel.apply(this, arguments) }, drawPoints: function () { var t, e = this.points.length; for (c.drawPoints.apply(this, arguments), t = 0; t < e;) { var i = this.points[t]; i.origProps = { plotY: i.plotY, plotX: i.plotX, isInside: i.isInside, negative: i.negative, zone: i.zone, y: i.y }, i.lowerGraphic = i.graphic, i.graphic = i.upperGraphic, i.plotY = i.plotHigh, o(i.plotHighX) && (i.plotX = i.plotHighX), i.y = i.high, i.negative = i.high < (this.options.threshold || 0), i.zone = this.zones.length && i.getZone(), this.chart.polar || (i.isInside = i.isTopInside = void 0 !== i.plotY && 0 <= i.plotY && i.plotY <= this.yAxis.len && 0 <= i.plotX && i.plotX <= this.xAxis.len), t++ } for (c.drawPoints.apply(this, arguments), t = 0; t < e;)(i = this.points[t]).upperGraphic = i.graphic, i.graphic = i.lowerGraphic, p(i, i.origProps), delete i.origProps, t++ }, setStackedPoints: t.noop }, { setState: function () { var t = this.state, e = this.series, i = e.chart.polar; o(this.plotHigh) || (this.plotHigh = e.yAxis.toPixels(this.high, !0)), o(this.plotLow) || (this.plotLow = this.plotY = e.yAxis.toPixels(this.low, !0)), e.stateMarkerGraphic && (e.lowerStateMarkerGraphic = e.stateMarkerGraphic, e.stateMarkerGraphic = e.upperStateMarkerGraphic), this.graphic = this.upperGraphic, this.plotY = this.plotHigh, i && (this.plotX = this.plotHighX), a.setState.apply(this, arguments), this.state = t, this.plotY = this.plotLow, this.graphic = this.lowerGraphic, i && (this.plotX = this.plotLowX), e.stateMarkerGraphic && (e.upperStateMarkerGraphic = e.stateMarkerGraphic, e.stateMarkerGraphic = e.lowerStateMarkerGraphic, e.lowerStateMarkerGraphic = void 0), a.setState.apply(this, arguments) }, haloPath: function () { var t = this.series.chart.polar, e = []; return this.plotY = this.plotLow, t && (this.plotX = this.plotLowX), this.isInside && (e = a.haloPath.apply(this, arguments)), this.plotY = this.plotHigh, t && (this.plotX = this.plotHighX), this.isTopInside && (e = e.concat(a.haloPath.apply(this, arguments))), e }, destroyElements: function () { return ["lowerGraphic", "upperGraphic"].forEach(function (t) { this[t] && (this[t] = this[t].destroy()) }, this), this.graphic = null, a.destroyElements.apply(this, arguments) }, isValid: function () { return s(this.low) && s(this.high) } }) }), e(t, "Series/AreaSplineRangeSeries.js", [t["Core/Globals.js"], t["Core/Utilities.js"]], function (t, e) { (e = e.seriesType)("areasplinerange", "arearange", null, { getPointSpline: t.seriesTypes.spline.prototype.getPointSpline }) }), e(t, "Series/ColumnRangeSeries.js", [t["Core/Globals.js"], t["Core/Options.js"], t["Core/Utilities.js"]], function (t, e, i) { e = e.defaultOptions; var g = i.clamp, o = i.merge, f = i.pick; i = i.seriesType; var s = t.noop, b = t.seriesTypes.column.prototype; i("columnrange", "arearange", o(e.plotOptions.column, e.plotOptions.arearange, { pointRange: null, marker: null, states: { hover: { halo: !1 } } }), { translate: function () { var a, r, n = this, h = n.yAxis, l = n.xAxis, p = l.startAngleRad, d = n.chart, c = n.xAxis.isRadial, u = Math.max(d.chartWidth, d.chartHeight) + 999; b.translate.apply(n), n.points.forEach(function (t) { var e = t.shapeArgs, i = n.options.minPointLength; t.plotHigh = r = g(h.translate(t.high, 0, 1, 0, 1), -u, u), t.plotLow = g(t.plotY, -u, u); var o = r, s = f(t.rectPlotY, t.plotY) - r; Math.abs(s) < i ? (s += i -= s, o -= i / 2) : s < 0 && (o -= s *= -1), c ? (a = t.barX + p, t.shapeType = "arc", t.shapeArgs = n.polarArc(o + s, o, a, a + t.pointWidth)) : (e.height = s, e.y = o, t.tooltipPos = d.inverted ? [h.len + h.pos - d.plotLeft - o - s / 2, l.len + l.pos - d.plotTop - e.x - e.width / 2, s] : [l.left - d.plotLeft + e.x + e.width / 2, h.pos - d.plotTop + o + s / 2, s]) }) }, directTouch: !0, trackerGroups: ["group", "dataLabelsGroup"], drawGraph: s, getSymbol: s, crispCol: function () { return b.crispCol.apply(this, arguments) }, drawPoints: function () { return b.drawPoints.apply(this, arguments) }, drawTracker: function () { return b.drawTracker.apply(this, arguments) }, getColumnMetrics: function () { return b.getColumnMetrics.apply(this, arguments) }, pointAttribs: function () { return b.pointAttribs.apply(this, arguments) }, animate: function () { return b.animate.apply(this, arguments) }, polarArc: function () { return b.polarArc.apply(this, arguments) }, translate3dPoints: function () { return b.translate3dPoints.apply(this, arguments) }, translate3dShapes: function () { return b.translate3dShapes.apply(this, arguments) } }, { setState: b.pointClass.prototype.setState }) }), e(t, "Series/ColumnPyramidSeries.js", [t["Core/Globals.js"], t["Core/Utilities.js"]], function (t, e) { var M = e.clamp, L = e.pick; e = e.seriesType; var i = t.seriesTypes.column.prototype; e("columnpyramid", "column", {}, { translate: function () { var c = this, u = c.chart, g = c.options, t = c.dense = c.closestPointRange * c.xAxis.transA < 2, t = c.borderWidth = L(g.borderWidth, t ? 0 : 1), f = c.yAxis, b = g.threshold, m = c.translatedThreshold = f.getThreshold(b), y = L(g.minPointLength, 5), e = c.getColumnMetrics(), v = e.width, x = c.barW = Math.max(v, 1 + 2 * t), P = c.pointXOffset = e.offset; u.inverted && (m -= .5), g.pointPadding && (x = Math.ceil(x)), i.translate.apply(c), c.points.forEach(function (t) { var e = L(t.yBottom, m), i = 999 + Math.abs(e), o = M(t.plotY, -i, f.len + i), i = t.plotX + P, s = x / 2, a = Math.min(o, e), e = Math.max(o, e) - a; t.barX = i, t.pointWidth = v, t.tooltipPos = u.inverted ? [f.len + f.pos - u.plotLeft - o, c.xAxis.len - i - s, e] : [i + s, o + f.pos - u.plotTop, e], o = b + (t.total || t.y), "percent" === g.stacking && (o = b + (t.y < 0) ? -100 : 100), o = f.toPixels(o, !0); var r = (h = u.plotHeight - o - (u.plotHeight - m)) ? s * (a - o) / h : 0, n = h ? s * (a + e - o) / h : 0, h = i - r + s, r = i + r + s, l = i + n + s, n = i - n + s, p = a - y, d = a + e; t.y < 0 && (d = (p = a) + e + y), u.inverted && (n = s * (o - ((l = u.plotWidth - a) - e)) / (h = o - (u.plotWidth - m)), r = (h = i + s + (r = s * (o - l) / h)) - 2 * r, l = i - n + s, n = i + n + s, d = (p = a) + e - y, t.y < 0 && (d = a + e + y)), t.shapeType = "path", t.shapeArgs = { x: h, y: p, width: r - h, height: e, d: [["M", h, p], ["L", r, p], ["L", l, d], ["L", n, d], ["Z"]] } }) } }) }), e(t, "Series/GaugeSeries.js", [t["Core/Globals.js"], t["Core/Utilities.js"]], function (t, e) { var c = e.clamp, u = e.isNumber, g = e.merge, f = e.pick, b = e.pInt; e = e.seriesType; var i = t.Series, o = t.TrackerMixin; e("gauge", "line", { dataLabels: { borderColor: "#cccccc", borderRadius: 3, borderWidth: 1, crop: !1, defer: !1, enabled: !0, verticalAlign: "top", y: 15, zIndex: 2 }, dial: {}, pivot: {}, tooltip: { headerFormat: "" }, showInLegend: !1 }, { angular: !0, directTouch: !0, drawGraph: t.noop, fixedBox: !0, forceDL: !0, noSharedTooltip: !0, trackerGroups: ["group", "dataLabelsGroup"], translate: function () { var l = this.yAxis, p = this.options, d = l.center; this.generatePoints(), this.points.forEach(function (t) { var e = g(p.dial, t.dial), i = b(f(e.radius, "80%")) * d[2] / 200, o = b(f(e.baseLength, "70%")) * i / 100, s = b(f(e.rearLength, "10%")) * i / 100, a = e.baseWidth || 3, r = e.topWidth || 1, n = p.overshoot, h = l.startAngleRad + l.translate(t.y, null, null, null, !0); !u(n) && !1 !== p.wrap || (n = u(n) ? n / 180 * Math.PI : 0, h = c(h, l.startAngleRad - n, l.endAngleRad + n)), h = 180 * h / Math.PI, t.shapeType = "path", t.shapeArgs = { d: e.path || [["M", -s, -a / 2], ["L", o, -a / 2], ["L", i, -r / 2], ["L", i, r / 2], ["L", o, a / 2], ["L", -s, a / 2], ["Z"]], translateX: d[0], translateY: d[1], rotation: h }, t.plotX = d[0], t.plotY = d[1] }) }, drawPoints: function () { var a = this, r = a.chart, t = a.yAxis.center, e = a.pivot, n = a.options, i = n.pivot, h = r.renderer; a.points.forEach(function (t) { var e = t.graphic, i = t.shapeArgs, o = i.d, s = g(n.dial, t.dial); e ? (e.animate(i), i.d = o) : t.graphic = h[t.shapeType](i).attr({ rotation: i.rotation, zIndex: 1 }).addClass("highcharts-dial").add(a.group), r.styledMode || t.graphic[e ? "animate" : "attr"]({ stroke: s.borderColor || "none", "stroke-width": s.borderWidth || 0, fill: s.backgroundColor || "#000000" }) }), e ? e.animate({ translateX: t[0], translateY: t[1] }) : (a.pivot = h.circle(0, 0, f(i.radius, 5)).attr({ zIndex: 2 }).addClass("highcharts-pivot").translate(t[0], t[1]).add(a.group), r.styledMode || a.pivot.attr({ "stroke-width": i.borderWidth || 0, stroke: i.borderColor || "#cccccc", fill: i.backgroundColor || "#000000" })) }, animate: function (t) { var i = this; t || i.points.forEach(function (t) { var e = t.graphic; e && (e.attr({ rotation: 180 * i.yAxis.startAngleRad / Math.PI }), e.animate({ rotation: t.shapeArgs.rotation }, i.options.animation)) }) }, render: function () { this.group = this.plotGroup("group", "series", this.visible ? "visible" : "hidden", this.options.zIndex, this.chart.seriesGroup), i.prototype.render.call(this), this.group.clip(this.chart.clipRect) }, setData: function (t, e) { i.prototype.setData.call(this, t, !1), this.processData(), this.generatePoints(), f(e, !0) && this.chart.redraw() }, hasData: function () { return !!this.points.length }, drawTracker: o && o.drawTrackerPoint }, { setState: function (t) { this.state = t } }) }), e(t, "Series/BoxPlotSeries.js", [t["Core/Globals.js"], t["Core/Utilities.js"]], function (t, e) { var C = e.pick; e = e.seriesType; var i = t.noop, o = t.seriesTypes; e("boxplot", "column", { threshold: null, tooltip: { pointFormat: '<span style="color:{point.color}">●</span> <b> {series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>' }, whiskerLength: "50%", fillColor: "#ffffff", lineWidth: 1, medianWidth: 2, whiskerWidth: 2 }, { pointArrayMap: ["low", "q1", "median", "q3", "high"], toYData: function (t) { return [t.low, t.q1, t.median, t.q3, t.high] }, pointValKey: "high", pointAttribs: function () { return {} }, drawDataLabels: i, translate: function () { var i = this.yAxis, t = this.pointArrayMap; o.column.prototype.translate.apply(this), this.points.forEach(function (e) { t.forEach(function (t) { null !== e[t] && (e[t + "Plot"] = i.translate(e[t], 0, 1, 0, 1)) }), e.plotHigh = e.highPlot }) }, drawPoints: function () { var l, p, d, c, u, g, f, b, m, y, v, x = this, P = x.options, M = x.chart, L = M.renderer, S = 0, k = !1 !== x.doQuartiles, w = x.options.whiskerLength; x.points.forEach(function (t) { var e = t.graphic, i = e ? "animate" : "attr", o = t.shapeArgs, s = {}, a = {}, r = {}, n = {}, h = t.color || x.color; void 0 !== t.plotY && (f = Math.round(o.width), b = Math.floor(o.x), m = b + f, y = Math.round(f / 2), l = Math.floor(k ? t.q1Plot : t.lowPlot), p = Math.floor(k ? t.q3Plot : t.lowPlot), d = Math.floor(t.highPlot), c = Math.floor(t.lowPlot), e || (t.graphic = e = L.g("point").add(x.group), t.stem = L.path().addClass("highcharts-boxplot-stem").add(e), w && (t.whiskers = L.path().addClass("highcharts-boxplot-whisker").add(e)), k && (t.box = L.path(void 0).addClass("highcharts-boxplot-box").add(e)), t.medianShape = L.path(void 0).addClass("highcharts-boxplot-median").add(e)), M.styledMode || (a.stroke = t.stemColor || P.stemColor || h, a["stroke-width"] = C(t.stemWidth, P.stemWidth, P.lineWidth), a.dashstyle = t.stemDashStyle || P.stemDashStyle || P.dashStyle, t.stem.attr(a), w && (r.stroke = t.whiskerColor || P.whiskerColor || h, r["stroke-width"] = C(t.whiskerWidth, P.whiskerWidth, P.lineWidth), r.dashstyle = t.whiskerDashStyle || P.whiskerDashStyle || P.dashStyle, t.whiskers.attr(r)), k && (s.fill = t.fillColor || P.fillColor || h, s.stroke = P.lineColor || h, s["stroke-width"] = P.lineWidth || 0, s.dashstyle = t.boxDashStyle || P.boxDashStyle || P.dashStyle, t.box.attr(s)), n.stroke = t.medianColor || P.medianColor || h, n["stroke-width"] = C(t.medianWidth, P.medianWidth, P.lineWidth), n.dashstyle = t.medianDashStyle || P.medianDashStyle || P.dashStyle, t.medianShape.attr(n)), g = t.stem.strokeWidth() % 2 / 2, e = [["M", S = b + y + g, p], ["L", S, d], ["M", S, l], ["L", S, c]], t.stem[i]({ d: e }), k && (g = t.box.strokeWidth() % 2 / 2, l = Math.floor(l) + g, p = Math.floor(p) + g, e = [["M", b += g, p], ["L", b, l], ["L", m += g, l], ["L", m, p], ["L", b, p], ["Z"]], t.box[i]({ d: e })), w && (g = t.whiskers.strokeWidth() % 2 / 2, d += g, c += g, v = /%$/.test(w) ? y * parseFloat(w) / 100 : w / 2, e = [["M", S - v, d], ["L", S + v, d], ["M", S - v, c], ["L", S + v, c]], t.whiskers[i]({ d: e })), u = Math.round(t.medianPlot), g = t.medianShape.strokeWidth() % 2 / 2, e = [["M", b, u += g], ["L", m, u]], t.medianShape[i]({ d: e })) }) }, setStackedPoints: i }) }), e(t, "Series/ErrorBarSeries.js", [t["Core/Globals.js"], t["Core/Utilities.js"]], function (t, e) { e = e.seriesType; var i = t.noop, o = t.seriesTypes; e("errorbar", "boxplot", { color: "#000000", grouping: !1, linkedTo: ":previous", tooltip: { pointFormat: '<span style="color:{point.color}">●</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>' }, whiskerWidth: null }, { type: "errorbar", pointArrayMap: ["low", "high"], toYData: function (t) { return [t.low, t.high] }, pointValKey: "high", doQuartiles: !1, drawDataLabels: o.arearange ? function () { var e = this.pointValKey; o.arearange.prototype.drawDataLabels.call(this), this.data.forEach(function (t) { t.y = t[e] }) } : i, getColumnMetrics: function () { return this.linkedParent && this.linkedParent.columnMetrics || o.column.prototype.getColumnMetrics.call(this) } }) }), e(t, "Series/WaterfallSeries.js", [t["Core/Axis/Axis.js"], t["Core/Chart/Chart.js"], t["Core/Globals.js"], t["Core/Series/Point.js"], t["Extensions/Stacking.js"], t["Core/Utilities.js"]], function (t, e, i, o, s, a) { var r = a.addEvent, n = a.arrayMax, h = a.arrayMin, u = a.correctFloat, l = a.isNumber, p = a.objectEach, m = a.pick; a = a.seriesType; var d, c, g, f = i.Series, y = i.seriesTypes; function b() { var t = this.waterfall.stacks; t && (t.changed = !1, delete t.alreadyChanged) } function v() { var t = this.options.stackLabels; t && t.enabled && this.waterfall.stacks && this.waterfall.renderStackTotals() } function x() { for (var t = this.axes, e = this.series, i = e.length; i--;)e[i].options.stacking && (t.forEach(function (t) { t.isXAxis || (t.waterfall.stacks.changed = !0) }), i = 0) } function P() { this.waterfall || (this.waterfall = new g(this)) } function M(t) { this.axis = t, this.stacks = { changed: !1 } } return c = d = d || {}, M.prototype.renderStackTotals = function () { var t = this.axis, e = t.waterfall.stacks, i = t.stacking && t.stacking.stackTotalGroup, o = new s(t, t.options.stackLabels, !1, 0, void 0); this.dummyStackItem = o, p(e, function (t) { p(t, function (t) { o.total = t.stackTotal, t.label && (o.label = t.label), s.prototype.render.call(o, i), t.label = o.label, delete o.label }) }), o.total = null }, g = M, c.Composition = g, c.compose = function (t, e) { r(t, "init", P), r(t, "afterBuildStacks", b), r(t, "afterRender", v), r(e, "beforeRedraw", x) }, a("waterfall", "column", { dataLabels: { inside: !0 }, lineWidth: 1, lineColor: "#333333", dashStyle: "Dot", borderColor: "#333333", states: { hover: { lineWidthPlus: 0 } } }, { pointValKey: "y", showLine: !0, generatePoints: function () { y.column.prototype.generatePoints.apply(this); for (var t = 0, e = this.points.length; t < e; t++) { var i = this.points[t], o = this.processedYData[t]; (i.isIntermediateSum || i.isSum) && (i.y = u(o)) } }, translate: function () { var t, e = this.options, i = this.yAxis, o = m(e.minPointLength, 5), s = o / 2, a = e.threshold, r = e.stacking, n = i.waterfall.stacks[this.stackKey]; y.column.prototype.translate.apply(this); for (var h = t = a, l = this.points, p = 0, e = l.length; p < e; p++) { var d, c = l[p], u = this.processedYData[p], g = c.shapeArgs, f = [0, u], b = c.y; r ? (n && (f = n[p], "overlap" === r ? (d = f.stackState[f.stateIndex--], d = 0 <= b ? d : d - b, Object.hasOwnProperty.call(f, "absolutePos") && delete f.absolutePos, Object.hasOwnProperty.call(f, "absoluteNeg") && delete f.absoluteNeg) : (0 <= b ? (d = f.threshold + f.posTotal, f.posTotal -= b) : (d = f.threshold + f.negTotal, f.negTotal -= b, d -= b), !f.posTotal && Object.hasOwnProperty.call(f, "absolutePos") && (f.posTotal = f.absolutePos, delete f.absolutePos), !f.negTotal && Object.hasOwnProperty.call(f, "absoluteNeg") && (f.negTotal = f.absoluteNeg, delete f.absoluteNeg)), c.isSum || (f.connectorThreshold = f.threshold + f.stackTotal), b = i.reversed ? (u = 0 <= b ? d - b : d + b, d) : (u = d) - b, c.below = u <= m(a, 0), g.y = i.translate(u, 0, 1, 0, 1), g.height = Math.abs(g.y - i.translate(b, 0, 1, 0, 1))), (b = i.waterfall.dummyStackItem) && (b.x = p, b.label = n[p].label, b.setOffset(this.pointXOffset || 0, this.barW || 0, this.stackedYNeg[p], this.stackedYPos[p]))) : (d = Math.max(h, h + b) + f[0], g.y = i.translate(d, 0, 1, 0, 1), c.isSum ? (g.y = i.translate(f[1], 0, 1, 0, 1), g.height = Math.min(i.translate(f[0], 0, 1, 0, 1), i.len) - g.y) : c.isIntermediateSum ? (b = 0 <= b ? (u = f[1] + t, t) : (u = t, f[1] + t), i.reversed && (u ^= b, u ^= b ^= u), g.y = i.translate(u, 0, 1, 0, 1), g.height = Math.abs(g.y - Math.min(i.translate(b, 0, 1, 0, 1), i.len)), t += f[1]) : (g.height = 0 < u ? i.translate(h, 0, 1, 0, 1) - g.y : i.translate(h, 0, 1, 0, 1) - i.translate(h - u, 0, 1, 0, 1), h += u, c.below = h < m(a, 0)), g.height < 0 && (g.y += g.height, g.height *= -1)), c.plotY = g.y = Math.round(g.y) - this.borderWidth % 2 / 2, g.height = Math.max(Math.round(g.height), .001), c.yBottom = g.y + g.height, g.height <= o && !c.isNull ? (g.height = o, g.y -= s, c.plotY = g.y, c.minPointLengthOffset = c.y < 0 ? -s : s) : (c.isNull && (g.width = 0), c.minPointLengthOffset = 0), g = c.plotY + (c.negative ? g.height : 0), this.chart.inverted ? c.tooltipPos[0] = i.len - g : c.tooltipPos[1] = g } }, processData: function (t) { for (var e, i, o, s, a = this.options, r = this.yData, n = a.data, h = r.length, l = a.threshold || 0, p = i = e = o = s = 0; p < h; p++) { var d = r[p], c = n && n[p] ? n[p] : {}; "sum" === d || c.isSum ? r[p] = u(i) : "intermediateSum" === d || c.isIntermediateSum ? (r[p] = u(e), e = 0) : (i += d, e += d), o = Math.min(i, o), s = Math.max(i, s) } f.prototype.processData.call(this, t), a.stacking || (this.dataMin = o + l, this.dataMax = s) }, toYData: function (t) { return t.isSum ? "sum" : t.isIntermediateSum ? "intermediateSum" : t.y }, updateParallelArrays: function (t, e) { f.prototype.updateParallelArrays.call(this, t, e), "sum" !== this.yData[0] && "intermediateSum" !== this.yData[0] || (this.yData[0] = null) }, pointAttribs: function (t, e) { var i = this.options.upColor; return i && !t.options.color && (t.color = 0 < t.y ? i : null), delete (t = y.column.prototype.pointAttribs.call(this, t, e)).dashstyle, t }, getGraphPath: function () { return [["M", 0, 0]] }, getCrispPath: function () { for (var t = this.data, e = this.yAxis, i = t.length, o = Math.round(this.graph.strokeWidth()) % 2 / 2, s = Math.round(this.borderWidth) % 2 / 2, a = this.xAxis.reversed, r = this.yAxis.reversed, n = this.options.stacking, h = [], l = 1; l < i; l++) { var p = t[l].shapeArgs, d = t[l - 1], c = t[l - 1].shapeArgs, u = e.waterfall.stacks[this.stackKey], g = 0 < d.y ? -c.height : 0; u && c && p && (u = u[l - 1], g = n ? (u = u.connectorThreshold, Math.round(e.translate(u, 0, 1, 0, 1) + (r ? g : 0)) - o) : c.y + d.minPointLengthOffset + s - o, h.push(["M", (c.x || 0) + (!a && c.width || 0), g], ["L", (p.x || 0) + (a && p.width || 0), g])), !n && h.length && c && (d.y < 0 && !r || 0 < d.y && r) && (h[h.length - 2][2] += c.height, h[h.length - 1][2] += c.height) } return h }, drawGraph: function () { f.prototype.drawGraph.call(this), this.graph.attr({ d: this.getCrispPath() }) }, setStackedPoints: function () { function t(t, e, i, o) { if (x) for (; i < x; i++)f.stackState[i] += o; else f.stackState[0] = t, x = f.stackState.length; f.stackState.push(f.stackState[x - 1] + e) } var e, i, o, s = this.options, a = this.yAxis.waterfall.stacks, r = s.threshold, n = r || 0, h = n, l = this.stackKey, p = this.xData, d = p.length; this.yAxis.stacking.usePercentage = !1; var c = i = o = n; if (this.visible || !this.chart.options.chart.ignoreHiddenSeries) { var u = a.changed; (e = a.alreadyChanged) && e.indexOf(l) < 0 && (u = !0), a[l] || (a[l] = {}), e = a[l]; for (var g = 0; g < d; g++) { e[y = p[g]] && !u || (e[y] = { negTotal: 0, posTotal: 0, stackTotal: 0, threshold: 0, stateIndex: 0, stackState: [], label: u && e[y] ? e[y].label : void 0 }); var f = e[y], b = this.yData[g]; 0 <= b ? f.posTotal += b : f.negTotal += b; var m = s.data[g], y = f.absolutePos = f.posTotal, v = f.absoluteNeg = f.negTotal; f.stackTotal = y + v; var x = f.stackState.length; m && m.isIntermediateSum ? (t(o, i, 0, o), o = i, i = r, n ^= h, n ^= h ^= n) : m && m.isSum ? (t(r, c, x), n = r) : (t(n, b, 0, c), m && (c += b, i += b)), f.stateIndex++, f.threshold = n, n += f.stackTotal } a.changed = !1, a.alreadyChanged || (a.alreadyChanged = []), a.alreadyChanged.push(l) } }, getExtremes: function () { var t = this.options.stacking; if (t) { var e = (e = this.yAxis).waterfall.stacks, i = this.stackedYNeg = [], o = this.stackedYPos = []; return p(e[this.stackKey], "overlap" === t ? function (t) { i.push(h(t.stackState)), o.push(n(t.stackState)) } : function (t) { i.push(t.negTotal + t.threshold), o.push(t.posTotal + t.threshold) }), { dataMin: h(i), dataMax: n(o) } } return { dataMin: this.dataMin, dataMax: this.dataMax } } }, { getClassName: function () { var t = o.prototype.getClassName.call(this); return this.isSum ? t += " highcharts-sum" : this.isIntermediateSum && (t += " highcharts-intermediate-sum"), t }, isValid: function () { return l(this.y) || this.isSum || !!this.isIntermediateSum } }), d.compose(t, e), d }), e(t, "Series/PolygonSeries.js", [t["Core/Globals.js"], t["Mixins/LegendSymbol.js"], t["Core/Utilities.js"]], function (t, e, i) { i = i.seriesType; var o = t.Series, s = t.seriesTypes; i("polygon", "scatter", { marker: { enabled: !1, states: { hover: { enabled: !1 } } }, stickyTracking: !1, tooltip: { followPointer: !0, pointFormat: "" }, trackByArea: !0 }, { type: "polygon", getGraphPath: function () { for (var t = o.prototype.getGraphPath.call(this), e = t.length + 1; e--;)(e === t.length || "M" === t[e][0]) && 0 < e && t.splice(e, 0, ["Z"]); return this.areaPath = t }, drawGraph: function () { this.options.fillColor = this.color, s.area.prototype.drawGraph.call(this) }, drawLegendSymbol: e.drawRectangle, drawTracker: o.prototype.drawTracker, setStackedPoints: t.noop }) }), e(t, "Series/Bubble/BubbleLegend.js", [t["Core/Chart/Chart.js"], t["Core/Color.js"], t["Core/Globals.js"], t["Core/Legend.js"], t["Core/Utilities.js"]], function (t, e, a, i, s) { var d = e.parse; e = s.addEvent; var r = s.arrayMax, n = s.arrayMin, h = s.isNumber, c = s.merge, l = s.objectEach, u = s.pick, o = s.setOptions, p = s.stableSort, g = s.wrap, f = a.Series, b = a.noop; function m(t, e) { this.options = this.symbols = this.visible = this.ranges = this.movementX = this.maxLabel = this.legendSymbol = this.legendItemWidth = this.legendItemHeight = this.legendItem = this.legendGroup = this.legend = this.fontMetrics = this.chart = void 0, this.setState = b, this.init(t, e) } return o({ legend: { bubbleLegend: { borderColor: void 0, borderWidth: 2, className: void 0, color: void 0, connectorClassName: void 0, connectorColor: void 0, connectorDistance: 60, connectorWidth: 1, enabled: !1, labels: { className: void 0, allowOverlap: !1, format: "", formatter: void 0, align: "right", style: { fontSize: 10, color: void 0 }, x: 0, y: 0 }, maxSize: 60, minSize: 10, legendIndex: 0, ranges: { value: void 0, borderColor: void 0, color: void 0, connectorColor: void 0 }, sizeBy: "area", sizeByAbsoluteValue: !1, zIndex: 1, zThreshold: 0 } } }), m.prototype.init = function (t, e) { this.options = t, this.visible = !0, this.chart = e.chart, this.legend = e }, m.prototype.addToLegend = function (t) { t.splice(this.options.legendIndex, 0, this) }, m.prototype.drawLegendSymbol = function (t) { var e = this.chart, i = this.options, o = u(t.options.itemDistance, 20), s = i.ranges, a = i.connectorDistance; this.fontMetrics = e.renderer.fontMetrics(i.labels.style.fontSize.toString() + "px"), s && s.length && h(s[0].value) ? (p(s, function (t, e) { return e.value - t.value }), this.ranges = s, this.setOptions(), this.render(), e = this.getMaxLabelSize(), t = 2 * (s = this.ranges[0].radius), a = 0 < (a = a - s + e.width) ? a : 0, this.maxLabel = e, this.movementX = "left" === i.labels.align ? a : 0, this.legendItemWidth = t + a + o, this.legendItemHeight = t + this.fontMetrics.h / 2) : t.options.bubbleLegend.autoRanges = !0 }, m.prototype.setOptions = function () { var i = this.ranges, o = this.options, s = this.chart.series[o.seriesIndex], a = this.legend.baseline, r = { "z-index": o.zIndex, "stroke-width": o.borderWidth }, n = { "z-index": o.zIndex, "stroke-width": o.connectorWidth }, h = this.getLabelStyles(), l = s.options.marker.fillOpacity, p = this.chart.styledMode; i.forEach(function (t, e) { p || (r.stroke = u(t.borderColor, o.borderColor, s.color), r.fill = u(t.color, o.color, 1 !== l ? d(s.color).setOpacity(l).get("rgba") : s.color), n.stroke = u(t.connectorColor, o.connectorColor, s.color)), i[e].radius = this.getRangeRadius(t.value), i[e] = c(i[e], { center: i[0].radius - i[e].radius + a }), p || c(!0, i[e], { bubbleStyle: c(!1, r), connectorStyle: c(!1, n), labelStyle: h }) }, this) }, m.prototype.getLabelStyles = function () { var t = this.options, i = {}, e = "left" === t.labels.align, o = this.legend.options.rtl; return l(t.labels.style, function (t, e) { "color" !== e && "fontSize" !== e && "z-index" !== e && (i[e] = t) }), c(!1, i, { "font-size": t.labels.style.fontSize, fill: u(t.labels.style.color, "#000000"), "z-index": t.zIndex, align: o || e ? "right" : "left" }) }, m.prototype.getRangeRadius = function (t) { var e = this.options; return this.chart.series[this.options.seriesIndex].getRadius.call(this, e.ranges[e.ranges.length - 1].value, e.ranges[0].value, e.minSize, e.maxSize, t) }, m.prototype.render = function () { var t = this.chart.renderer, e = this.options.zThreshold; this.symbols || (this.symbols = { connectors: [], bubbleItems: [], labels: [] }), this.legendSymbol = t.g("bubble-legend"), this.legendItem = t.g("bubble-legend-item"), this.legendSymbol.translateX = 0, this.legendSymbol.translateY = 0, this.ranges.forEach(function (t) { t.value >= e && this.renderRange(t) }, this), this.legendSymbol.add(this.legendItem), this.legendItem.add(this.legendGroup), this.hideOverlappingLabels() }, m.prototype.renderRange = function (t) { var e = this.options, i = e.labels, o = this.chart.renderer, s = this.symbols, a = s.labels, r = t.center, n = Math.abs(t.radius), h = e.connectorDistance || 0, l = i.align, p = i.style.fontSize, h = this.legend.options.rtl || "left" === l ? -h : h, i = e.connectorWidth, d = this.ranges[0].radius || 0, c = r - n - e.borderWidth / 2 + i / 2, p = p / 2 - (this.fontMetrics.h - p) / 2, u = o.styledMode; "center" === l && (h = 0, e.connectorDistance = 0, t.labelStyle.align = "center"), l = c + e.labels.y; var g = d + h + e.labels.x; s.bubbleItems.push(o.circle(d, r + ((c % 1 ? 1 : .5) - (i % 2 ? 0 : .5)), n).attr(u ? {} : t.bubbleStyle).addClass((u ? "highcharts-color-" + this.options.seriesIndex + " " : "") + "highcharts-bubble-legend-symbol " + (e.className || "")).add(this.legendSymbol)), s.connectors.push(o.path(o.crispLine([["M", d, c], ["L", d + h, c]], e.connectorWidth)).attr(u ? {} : t.connectorStyle).addClass((u ? "highcharts-color-" + this.options.seriesIndex + " " : "") + "highcharts-bubble-legend-connectors " + (e.connectorClassName || "")).add(this.legendSymbol)), t = o.text(this.formatLabel(t), g, l + p).attr(u ? {} : t.labelStyle).addClass("highcharts-bubble-legend-labels " + (e.labels.className || "")).add(this.legendSymbol), a.push(t), t.placed = !0, t.alignAttr = { x: g, y: l + p } }, m.prototype.getMaxLabelSize = function () { var e, i; return this.symbols.labels.forEach(function (t) { i = t.getBBox(!0), e = !e || i.width > e.width ? i : e }), e || {} }, m.prototype.formatLabel = function (t) { var e = (i = this.options).labels.formatter, i = i.labels.format, o = this.chart.numberFormatter; return i ? s.format(i, t) : e ? e.call(t) : o(t.value, 1) }, m.prototype.hideOverlappingLabels = function () { var t = this.chart, i = this.symbols; !this.options.labels.allowOverlap && i && (t.hideOverlappingLabels(i.labels), i.labels.forEach(function (t, e) { t.newOpacity ? t.newOpacity !== t.oldOpacity && i.connectors[e].show() : i.connectors[e].hide() })) }, m.prototype.getRanges = function () { var e, t = this.legend.bubbleLegend, i = t.options.ranges, o = Number.MAX_VALUE, s = -Number.MAX_VALUE; t.chart.series.forEach(function (t) { t.isBubble && !t.ignoreSeries && (e = t.zData.filter(h)).length && (o = u(t.options.zMin, Math.min(o, Math.max(n(e), !1 === t.options.displayNegative ? t.options.zThreshold : -Number.MAX_VALUE))), s = u(t.options.zMax, Math.max(s, r(e)))) }); var a = o === s ? [{ value: s }] : [{ value: o }, { value: (o + s) / 2 }, { value: s, autoRanges: !0 }]; return i.length && i[0].radius && a.reverse(), a.forEach(function (t, e) { i && i[e] && (a[e] = c(!1, i[e], t)) }), a }, m.prototype.predictBubbleSizes = function () { var t = this.chart, e = this.fontMetrics, i = t.legend.options, o = "horizontal" === i.layout, s = o ? t.legend.lastLineHeight : 0, a = t.plotSizeX, r = t.plotSizeY, n = t.series[this.options.seriesIndex], t = Math.ceil(n.minPxSize), h = Math.ceil(n.maxPxSize), n = n.options.maxSize, l = Math.min(r, a); return i.floating || !/%$/.test(n) ? e = h : (n = parseFloat(n), e = (l + s - e.h / 2) * n / 100 / (n / 100 + 1), (o && a <= r - e || !o && r <= a - e) && (e = h)), [t, Math.ceil(e)] }, m.prototype.updateRanges = function (t, e) { var i = this.legend.options.bubbleLegend; i.minSize = t, i.maxSize = e, i.ranges = this.getRanges() }, m.prototype.correctSizes = function () { var t = this.legend, e = this.chart.series[this.options.seriesIndex]; 1 < Math.abs(Math.ceil(e.maxPxSize) - this.options.maxSize) && (this.updateRanges(this.options.minSize, e.maxPxSize), t.render()) }, o = m, e(i, "afterGetAllItems", function (t) { var e = this.bubbleLegend, i = this.options, o = i.bubbleLegend, s = this.chart.getVisibleBubbleSeriesIndex(); e && e.ranges && e.ranges.length && (o.ranges.length && (o.autoRanges = !!o.ranges[0].autoRanges), this.destroyItem(e)), 0 <= s && i.enabled && o.enabled && (o.seriesIndex = s, this.bubbleLegend = new a.BubbleLegend(o, this), this.bubbleLegend.addToLegend(t.allItems)) }), t.prototype.getVisibleBubbleSeriesIndex = function () { for (var t = this.series, e = 0; e < t.length;) { if (t[e] && t[e].isBubble && t[e].visible && t[e].zData.length) return e; e++ } return -1 }, i.prototype.getLinesHeights = function () { for (var t = this.allItems, e = [], i = t.length, o = 0, s = 0; s < i; s++)if (t[s].legendItemHeight && (t[s].itemHeight = t[s].legendItemHeight), t[s] === t[i - 1] || t[s + 1] && t[s]._legendItemPos[1] !== t[s + 1]._legendItemPos[1]) { e.push({ height: 0 }); for (var a = e[e.length - 1]; o <= s; o++)t[o].itemHeight > a.height && (a.height = t[o].itemHeight); a.step = s } return e }, i.prototype.retranslateItems = function (i) { var o, s, a, r = this.options.rtl, n = 0; this.allItems.forEach(function (t, e) { o = t.legendGroup.translateX, s = t._legendItemPos[1], ((a = t.movementX) || r && t.ranges) && (a = r ? o - t.options.maxSize / 2 : o + a, t.legendGroup.attr({ translateX: a })), e > i[n].step && n++, t.legendGroup.attr({ translateY: Math.round(s + i[n].height / 2) }), t._legendItemPos[1] = s + i[n].height / 2 }) }, e(f, "legendItemClick", function () { var t = this.chart, e = this.visible, i = this.chart.legend; i && i.bubbleLegend && (this.visible = !e, this.ignoreSeries = e, t = 0 <= t.getVisibleBubbleSeriesIndex(), i.bubbleLegend.visible !== t && (i.update({ bubbleLegend: { enabled: t } }), i.bubbleLegend.visible = t), this.visible = e) }), g(t.prototype, "drawChartBox", function (t, e, i) { var o, s = this.legend, a = 0 <= this.getVisibleBubbleSeriesIndex(); s && s.options.enabled && s.bubbleLegend && s.options.bubbleLegend.autoRanges && a ? (o = s.bubbleLegend.options, a = s.bubbleLegend.predictBubbleSizes(), s.bubbleLegend.updateRanges(a[0], a[1]), o.placed || (s.group.placed = !1, s.allItems.forEach(function (t) { t.legendGroup.translateY = null })), s.render(), this.getMargins(), this.axes.forEach(function (t) { t.visible && t.render(), o.placed || (t.setScale(), t.updateNames(), l(t.ticks, function (t) { t.isNew = !0, t.isNewLabel = !0 })) }), o.placed = !0, this.getMargins(), t.call(this, e, i), s.bubbleLegend.correctSizes(), s.retranslateItems(s.getLinesHeights())) : (t.call(this, e, i), s && s.options.enabled && s.bubbleLegend && (s.render(), s.retranslateItems(s.getLinesHeights()))) }), a.BubbleLegend = o, a.BubbleLegend }), e(t, "Series/Bubble/BubbleSeries.js", [t["Core/Globals.js"], t["Core/Color.js"], t["Core/Series/Point.js"], t["Core/Utilities.js"]], function (t, e, i, o) { var s = e.parse, b = o.arrayMax, m = o.arrayMin, y = o.clamp, a = o.extend, v = o.isNumber, x = o.pick, P = o.pInt; e = o.seriesType, o = t.Axis; var r = t.noop, n = t.Series, h = t.seriesTypes; e("bubble", "scatter", { dataLabels: { formatter: function () { return this.point.z }, inside: !0, verticalAlign: "middle" }, animationLimit: 250, marker: { lineColor: null, lineWidth: 1, fillOpacity: .5, radius: null, states: { hover: { radiusPlus: 0 } }, symbol: "circle" }, minSize: 8, maxSize: "20%", softThreshold: !1, states: { hover: { halo: { size: 5 } } }, tooltip: { pointFormat: "({point.x}, {point.y}), Size: {point.z}" }, turboThreshold: 0, zThreshold: 0, zoneAxis: "z" }, { pointArrayMap: ["y", "z"], parallelArrays: ["x", "y", "z"], trackerGroups: ["group", "dataLabelsGroup"], specialGroup: "group", bubblePadding: !0, zoneAxis: "z", directTouch: !0, isBubble: !0, pointAttribs: function (t, e) { var i = this.options.marker.fillOpacity; return t = n.prototype.pointAttribs.call(this, t, e), 1 !== i && (t.fill = s(t.fill).setOpacity(i).get("rgba")), t }, getRadii: function (t, e, i) { var o = this.zData, s = this.yData, a = i.minPxSize, r = i.maxPxSize, n = [], h = 0; for (i = o.length; h < i; h++) { var l = o[h]; n.push(this.getRadius(t, e, a, r, l, s[h])) } this.radii = n }, getRadius: function (t, e, i, o, s, a) { var r = this.options, n = "width" !== r.sizeBy, h = r.zThreshold, l = e - t, p = .5; if (null === a || null === s) return null; if (v(s)) { if (r.sizeByAbsoluteValue && (s = Math.abs(s - h), l = Math.max(e - h, Math.abs(t - h)), t = 0), s < t) return i / 2 - 1; 0 < l && (p = (s - t) / l) } return n && 0 <= p && (p = Math.sqrt(p)), Math.ceil(i + p * (o - i)) / 2 }, animate: function (t) { !t && this.points.length < this.options.animationLimit && this.points.forEach(function (t) { var e = t.graphic; e && e.width && (this.hasRendered || e.attr({ x: t.plotX, y: t.plotY, width: 1, height: 1 }), e.animate(this.markerAttribs(t), this.options.animation)) }, this) }, hasData: function () { return !!this.processedXData.length }, translate: function () { var t, e = this.data, i = this.radii; for (h.scatter.prototype.translate.call(this), t = e.length; t--;) { var o = e[t], s = i ? i[t] : 0; v(s) && s >= this.minPxSize / 2 ? (o.marker = a(o.marker, { radius: s, width: 2 * s, height: 2 * s }), o.dlBox = { x: o.plotX - s, y: o.plotY - s, width: 2 * s, height: 2 * s }) : o.shapeArgs = o.plotY = o.dlBox = void 0 } }, alignDataLabel: h.column.prototype.alignDataLabel, buildKDTree: r, applyZones: r }, { haloPath: function (t) { return i.prototype.haloPath.call(this, 0 === t ? 0 : (this.marker && this.marker.radius || 0) + t) }, ttBelow: !1 }), o.prototype.beforePadding = function () { var s = this, t = this.len, e = this.chart, a = 0, r = t, n = this.isXAxis, h = n ? "xData" : "yData", l = this.min, p = {}, d = Math.min(e.plotWidth, e.plotHeight), c = Number.MAX_VALUE, u = -Number.MAX_VALUE, g = this.max - l, f = t / g, i = []; this.series.forEach(function (t) { var o = t.options; !t.bubblePadding || !t.visible && e.options.chart.ignoreHiddenSeries || (s.allowZoomOutside = !0, i.push(t), n && (["minSize", "maxSize"].forEach(function (t) { var e = o[t], i = /%$/.test(e), e = P(e); p[t] = i ? d * e / 100 : e }), t.minPxSize = p.minSize, t.maxPxSize = Math.max(p.maxSize, p.minSize), (t = t.zData.filter(v)).length && (c = x(o.zMin, y(m(t), !1 === o.displayNegative ? o.zThreshold : -Number.MAX_VALUE, c)), u = x(o.zMax, Math.max(u, b(t)))))) }), i.forEach(function (t) { var e, i = t[h], o = i.length; if (n && t.getRadii(c, u, t), 0 < g) for (; o--;) { v(i[o]) && s.dataMin <= i[o] && i[o] <= s.max && (e = t.radii ? t.radii[o] : 0, a = Math.min((i[o] - l) * f - e, a), r = Math.max((i[o] - l) * f + e, r)) } }), i.length && 0 < g && !this.logarithmic && (r -= t, f *= (t + Math.max(0, a) - Math.min(r, t)) / t, [["min", "userMin", a], ["max", "userMax", r]].forEach(function (t) { void 0 === x(s.options[t[0]], s[t[1]]) && (s[t[0]] += t[2] / f) })) } }), e(t, "Series/Networkgraph/DraggableNodes.js", [t["Core/Chart/Chart.js"], t["Core/Globals.js"], t["Core/Utilities.js"]], function (t, e, i) { var a = i.addEvent; e.dragNodesMixin = { onMouseDown: function (t, e) { e = this.chart.pointer.normalize(e), t.fixedPosition = { chartX: e.chartX, chartY: e.chartY, plotX: t.plotX, plotY: t.plotY }, t.inDragMode = !0 }, onMouseMove: function (t, e) { var i, o, s; t.fixedPosition && t.inDragMode && (e = (i = this.chart).pointer.normalize(e), o = t.fixedPosition.chartX - e.chartX, s = t.fixedPosition.chartY - e.chartY, e = i.graphLayoutsLookup, (5 < Math.abs(o) || 5 < Math.abs(s)) && (o = t.fixedPosition.plotX - o, s = t.fixedPosition.plotY - s, i.isInsidePlot(o, s) && (t.plotX = o, t.plotY = s, t.hasDragged = !0, this.redrawHalo(t), e.forEach(function (t) { t.restartSimulation() })))) }, onMouseUp: function (t, e) { t.fixedPosition && t.hasDragged && (this.layout.enableSimulation ? this.layout.start() : this.chart.redraw(), t.inDragMode = t.hasDragged = !1, this.options.fixedDraggable || delete t.fixedPosition) }, redrawHalo: function (t) { t && this.halo && this.halo.attr({ d: t.haloPath(this.options.states.hover.halo.size) }) } }, a(t, "load", function () { var t, i, o, s = this; s.container && (t = a(s.container, "mousedown", function (t) { var e = s.hoverPoint; e && e.series && e.series.hasDraggableNodes && e.series.options.draggable && (e.series.onMouseDown(e, t), i = a(s.container, "mousemove", function (t) { return e && e.series && e.series.onMouseMove(e, t) }), o = a(s.container.ownerDocument, "mouseup", function (t) { return i(), o(), e && e.series && e.series.onMouseUp(e, t) })) })), a(s, "destroy", function () { t() }) }) }), e(t, "Series/Networkgraph/Integrations.js", [t["Core/Globals.js"]], function (t) { t.networkgraphIntegrations = { verlet: { attractiveForceFunction: function (t, e) { return (e - t) / t }, repulsiveForceFunction: function (t, e) { return (e - t) / t * (t < e ? 1 : 0) }, barycenter: function () { var t = this.options.gravitationalConstant, e = this.barycenter.xFactor, i = this.barycenter.yFactor, e = (e - (this.box.left + this.box.width) / 2) * t, i = (i - (this.box.top + this.box.height) / 2) * t; this.nodes.forEach(function (t) { t.fixedPosition || (t.plotX -= e / t.mass / t.degree, t.plotY -= i / t.mass / t.degree) }) }, repulsive: function (t, e, i) { e = e * this.diffTemperature / t.mass / t.degree, t.fixedPosition || (t.plotX += i.x * e, t.plotY += i.y * e) }, attractive: function (t, e, i) { var o = t.getMass(), s = -i.x * e * this.diffTemperature; e = -i.y * e * this.diffTemperature, t.fromNode.fixedPosition || (t.fromNode.plotX -= s * o.fromNode / t.fromNode.degree, t.fromNode.plotY -= e * o.fromNode / t.fromNode.degree), t.toNode.fixedPosition || (t.toNode.plotX += s * o.toNode / t.toNode.degree, t.toNode.plotY += e * o.toNode / t.toNode.degree) }, integrate: function (t, e) { var i = -t.options.friction, o = t.options.maxSpeed, s = (e.plotX + e.dispX - e.prevX) * i; i *= e.plotY + e.dispY - e.prevY; var a = (r = Math.abs)(s) / (s || 1), r = r(i) / (i || 1), s = a * Math.min(o, Math.abs(s)), i = r * Math.min(o, Math.abs(i)); e.prevX = e.plotX + e.dispX, e.prevY = e.plotY + e.dispY, e.plotX += s, e.plotY += i, e.temperature = t.vectorLength({ x: s, y: i }) }, getK: function (t) { return Math.pow(t.box.width * t.box.height / t.nodes.length, .5) } }, euler: { attractiveForceFunction: function (t, e) { return t * t / e }, repulsiveForceFunction: function (t, e) { return e * e / t }, barycenter: function () { var i = this.options.gravitationalConstant, o = this.barycenter.xFactor, s = this.barycenter.yFactor; this.nodes.forEach(function (t) { var e; t.fixedPosition || (e = t.getDegree(), e *= 1 + e / 2, t.dispX += (o - t.plotX) * i * e / t.degree, t.dispY += (s - t.plotY) * i * e / t.degree) }) }, repulsive: function (t, e, i, o) { t.dispX += i.x / o * e / t.degree, t.dispY += i.y / o * e / t.degree }, attractive: function (t, e, i, o) { var s = t.getMass(), a = i.x / o * e; e *= i.y / o, t.fromNode.fixedPosition || (t.fromNode.dispX -= a * s.fromNode / t.fromNode.degree, t.fromNode.dispY -= e * s.fromNode / t.fromNode.degree), t.toNode.fixedPosition || (t.toNode.dispX += a * s.toNode / t.toNode.degree, t.toNode.dispY += e * s.toNode / t.toNode.degree) }, integrate: function (t, e) { e.dispX += e.dispX * t.options.friction, e.dispY += e.dispY * t.options.friction; var i = e.temperature = t.vectorLength({ x: e.dispX, y: e.dispY }); 0 !== i && (e.plotX += e.dispX / i * Math.min(Math.abs(e.dispX), t.temperature), e.plotY += e.dispY / i * Math.min(Math.abs(e.dispY), t.temperature)) }, getK: function (t) { return Math.pow(t.box.width * t.box.height / t.nodes.length, .3) } } } }), e(t, "Series/Networkgraph/QuadTree.js", [t["Core/Globals.js"], t["Core/Utilities.js"]], function (t, e) { e = e.extend; var s = t.QuadTreeNode = function (t) { this.box = t, this.boxSize = Math.min(t.width, t.height), this.nodes = [], this.body = this.isInternal = !1, this.isEmpty = !0 }; e(s.prototype, { insert: function (t, e) { this.isInternal ? this.nodes[this.getBoxPosition(t)].insert(t, e - 1) : (this.isEmpty = !1, this.body ? e ? (this.isInternal = !0, this.divideBox(), !0 !== this.body && (this.nodes[this.getBoxPosition(this.body)].insert(this.body, e - 1), this.body = !0), this.nodes[this.getBoxPosition(t)].insert(t, e - 1)) : ((e = new s({ top: t.plotX, left: t.plotY, width: .1, height: .1 })).body = t, e.isInternal = !1, this.nodes.push(e)) : (this.isInternal = !1, this.body = t)) }, updateMassAndCenter: function () { var e = 0, i = 0, o = 0; this.isInternal ? (this.nodes.forEach(function (t) { t.isEmpty || (e += t.mass, i += t.plotX * t.mass, o += t.plotY * t.mass) }), i /= e, o /= e) : this.body && (e = this.body.mass, i = this.body.plotX, o = this.body.plotY), this.mass = e, this.plotX = i, this.plotY = o }, divideBox: function () { var t = this.box.width / 2, e = this.box.height / 2; this.nodes[0] = new s({ left: this.box.left, top: this.box.top, width: t, height: e }), this.nodes[1] = new s({ left: this.box.left + t, top: this.box.top, width: t, height: e }), this.nodes[2] = new s({ left: this.box.left + t, top: this.box.top + e, width: t, height: e }), this.nodes[3] = new s({ left: this.box.left, top: this.box.top + e, width: t, height: e }) }, getBoxPosition: function (t) { var e = t.plotY < this.box.top + this.box.height / 2; return t.plotX < this.box.left + this.box.width / 2 ? e ? 0 : 3 : e ? 1 : 2 } }), e((t = t.QuadTree = function (t, e, i, o) { this.box = { left: t, top: e, width: i, height: o }, this.maxDepth = 25, this.root = new s(this.box, "0"), this.root.isInternal = !0, this.root.isRoot = !0, this.root.divideBox() }).prototype, { insertNodes: function (t) { t.forEach(function (t) { this.root.insert(t, this.maxDepth) }, this) }, visitNodeRecursive: function (t, e, i) { var o; (t = t || this.root) === this.root && e && (o = e(t)), !1 !== o && (t.nodes.forEach(function (t) { if (t.isInternal) { if (e && (o = e(t)), !1 === o) return; this.visitNodeRecursive(t, e, i) } else t.body && e && e(t.body); i && i(t) }, this), t === this.root && i && i(t)) }, calculateMassAndCenter: function () { this.visitNodeRecursive(null, null, function (t) { t.updateMassAndCenter() }) } }) }), e(t, "Series/Networkgraph/Layouts.js", [t["Core/Chart/Chart.js"], t["Core/Globals.js"], t["Core/Utilities.js"]], function (t, i, e) { var o = e.addEvent, s = e.clamp, a = e.defined, r = e.extend, n = e.isFunction, h = e.pick, l = e.setAnimation; i.layouts = { "reingold-fruchterman": function () { } }, r(i.layouts["reingold-fruchterman"].prototype, { init: function (t) { this.options = t, this.nodes = [], this.links = [], this.series = [], this.box = { x: 0, y: 0, width: 0, height: 0 }, this.setInitialRendering(!0), this.integration = i.networkgraphIntegrations[t.integration], this.enableSimulation = t.enableSimulation, this.attractiveForce = h(t.attractiveForce, this.integration.attractiveForceFunction), this.repulsiveForce = h(t.repulsiveForce, this.integration.repulsiveForceFunction), this.approximation = t.approximation }, updateSimulation: function (t) { this.enableSimulation = h(t, this.options.enableSimulation) }, start: function () { var t = this.series, e = this.options; this.currentStep = 0, this.forces = t[0] && t[0].forces || [], this.chart = t[0] && t[0].chart, this.initialRendering && (this.initPositions(), t.forEach(function (t) { t.finishedAnimating = !0, t.render() })), this.setK(), this.resetSimulation(e), this.enableSimulation && this.step() }, step: function () { var e = this, t = this.series; e.currentStep++, "barnes-hut" === e.approximation && (e.createQuadTree(), e.quadTree.calculateMassAndCenter()), e.forces.forEach(function (t) { e[t + "Forces"](e.temperature) }), e.applyLimits(e.temperature), e.temperature = e.coolDown(e.startTemperature, e.diffTemperature, e.currentStep), e.prevSystemTemperature = e.systemTemperature, e.systemTemperature = e.getSystemTemperature(), e.enableSimulation && (t.forEach(function (t) { t.chart && t.render() }), e.maxIterations-- && isFinite(e.temperature) && !e.isStable() ? (e.simulation && i.win.cancelAnimationFrame(e.simulation), e.simulation = i.win.requestAnimationFrame(function () { e.step() })) : e.simulation = !1) }, stop: function () { this.simulation && i.win.cancelAnimationFrame(this.simulation) }, setArea: function (t, e, i, o) { this.box = { left: t, top: e, width: i, height: o } }, setK: function () { this.k = this.options.linkLength || this.integration.getK(this) }, addElementsToCollection: function (t, e) { t.forEach(function (t) { -1 === e.indexOf(t) && e.push(t) }) }, removeElementFromCollection: function (t, e) { -1 !== (t = e.indexOf(t)) && e.splice(t, 1) }, clear: function () { this.nodes.length = 0, this.links.length = 0, this.series.length = 0, this.resetSimulation() }, resetSimulation: function () { this.forcedStop = !1, this.systemTemperature = 0, this.setMaxIterations(), this.setTemperature(), this.setDiffTemperature() }, restartSimulation: function () { this.simulation ? this.resetSimulation() : (this.setInitialRendering(!1), this.enableSimulation ? this.start() : this.setMaxIterations(1), this.chart && this.chart.redraw(), this.setInitialRendering(!0)) }, setMaxIterations: function (t) { this.maxIterations = h(t, this.options.maxIterations) }, setTemperature: function () { this.temperature = this.startTemperature = Math.sqrt(this.nodes.length) }, setDiffTemperature: function () { this.diffTemperature = this.startTemperature / (this.options.maxIterations + 1) }, setInitialRendering: function (t) { this.initialRendering = t }, createQuadTree: function () { this.quadTree = new i.QuadTree(this.box.left, this.box.top, this.box.width, this.box.height), this.quadTree.insertNodes(this.nodes) }, initPositions: function () { var t = this.options.initialPositions; n(t) ? (t.call(this), this.nodes.forEach(function (t) { a(t.prevX) || (t.prevX = t.plotX), a(t.prevY) || (t.prevY = t.plotY), t.dispX = 0, t.dispY = 0 })) : "circle" === t ? this.setCircularPositions() : this.setRandomPositions() }, setCircularPositions: function () { var i = this.box, t = this.nodes, o = 2 * Math.PI / (t.length + 1), e = t.filter(function (t) { return 0 === t.linksTo.length }), s = [], a = {}, r = this.options.initialPositionRadius; e.forEach(function (t) { s.push(t), function e(t) { t.linksFrom.forEach(function (t) { a[t.toNode.id] || (a[t.toNode.id] = !0, s.push(t.toNode), e(t.toNode)) }) }(t) }), s.length ? t.forEach(function (t) { -1 === s.indexOf(t) && s.push(t) }) : s = t, s.forEach(function (t, e) { t.plotX = t.prevX = h(t.plotX, i.width / 2 + r * Math.cos(e * o)), t.plotY = t.prevY = h(t.plotY, i.height / 2 + r * Math.sin(e * o)), t.dispX = 0, t.dispY = 0 }) }, setRandomPositions: function () { function i(t) { return (t = t * t / Math.PI) - Math.floor(t) } var o = this.box, t = this.nodes, s = t.length + 1; t.forEach(function (t, e) { t.plotX = t.prevX = h(t.plotX, o.width * i(e)), t.plotY = t.prevY = h(t.plotY, o.height * i(s + e)), t.dispX = 0, t.dispY = 0 }) }, force: function (t) { this.integration[t].apply(this, Array.prototype.slice.call(arguments, 1)) }, barycenterForces: function () { this.getBarycenter(), this.force("barycenter") }, getBarycenter: function () { var e = 0, i = 0, o = 0; return this.nodes.forEach(function (t) { i += t.plotX * t.mass, o += t.plotY * t.mass, e += t.mass }), this.barycenter = { x: i, y: o, xFactor: i / e, yFactor: o / e } }, barnesHutApproximation: function (t, e) { var i, o, s = this.getDistXY(t, e), a = this.vectorLength(s); return t !== e && 0 !== a && (e.isInternal ? o = !(e.boxSize / a < this.options.theta && 0 !== a) || (i = this.repulsiveForce(a, this.k), this.force("repulsive", t, i * e.mass, s, a), !1) : (i = this.repulsiveForce(a, this.k), this.force("repulsive", t, i * e.mass, s, a))), o }, repulsiveForces: function () { var a = this; "barnes-hut" === a.approximation ? a.nodes.forEach(function (e) { a.quadTree.visitNodeRecursive(null, function (t) { return a.barnesHutApproximation(e, t) }) }) : a.nodes.forEach(function (s) { a.nodes.forEach(function (t) { var e, i, o; s === t || s.fixedPosition || (e = a.getDistXY(s, t), 0 !== (i = a.vectorLength(e)) && (o = a.repulsiveForce(i, a.k), a.force("repulsive", s, o * t.mass, e, i))) }) }) }, attractiveForces: function () { var e, i, o, s = this; s.links.forEach(function (t) { t.fromNode && t.toNode && (e = s.getDistXY(t.fromNode, t.toNode), 0 !== (i = s.vectorLength(e)) && (o = s.attractiveForce(i, s.k), s.force("attractive", t, o, e, i))) }) }, applyLimits: function () { var e = this; e.nodes.forEach(function (t) { t.fixedPosition || (e.integration.integrate(e, t), e.applyLimitBox(t, e.box), t.dispX = 0, t.dispY = 0) }) }, applyLimitBox: function (t, e) { var i = t.radius; t.plotX = s(t.plotX, e.left + i, e.width - i), t.plotY = s(t.plotY, e.top + i, e.height - i) }, coolDown: function (t, e, i) { return t - e * i }, isStable: function () { return Math.abs(this.systemTemperature - this.prevSystemTemperature) < 1e-5 || this.temperature <= 0 }, getSystemTemperature: function () { return this.nodes.reduce(function (t, e) { return t + e.temperature }, 0) }, vectorLength: function (t) { return Math.sqrt(t.x * t.x + t.y * t.y) }, getDistR: function (t, e) { return t = this.getDistXY(t, e), this.vectorLength(t) }, getDistXY: function (t, e) { var i = t.plotX - e.plotX; return { x: i, y: t = t.plotY - e.plotY, absX: Math.abs(i), absY: Math.abs(t) } } }), o(t, "predraw", function () { this.graphLayoutsLookup && this.graphLayoutsLookup.forEach(function (t) { t.stop() }) }), o(t, "render", function () { function t(t) { t.maxIterations-- && isFinite(t.temperature) && !t.isStable() && !t.enableSimulation && (t.beforeStep && t.beforeStep(), t.step(), e = !(i = !1)) } var e = !1; if (this.graphLayoutsLookup) { for (l(!1, this), this.graphLayoutsLookup.forEach(function (t) { t.start() }); !i;) { var i = !0; this.graphLayoutsLookup.forEach(t) } e && this.series.forEach(function (t) { t && t.layout && t.render() }) } }), o(t, "beforePrint", function () { this.graphLayoutsLookup && (this.graphLayoutsLookup.forEach(function (t) { t.updateSimulation(!1) }), this.redraw()) }), o(t, "afterPrint", function () { this.graphLayoutsLookup && this.graphLayoutsLookup.forEach(function (t) { t.updateSimulation() }), this.redraw() }) }), e(t, "Series/PackedBubbleSeries.js", [t["Core/Chart/Chart.js"], t["Core/Color.js"], t["Core/Globals.js"], t["Core/Series/Point.js"], t["Core/Utilities.js"]], function (t, e, a, r, i) { var o = e.parse, s = i.addEvent, g = i.clamp, h = i.defined, l = i.extend; e = i.extendClass; var p = i.fireEvent, n = i.isArray, d = i.isNumber, c = i.merge, u = i.pick; i = i.seriesType; var f = a.Series, b = a.layouts["reingold-fruchterman"], m = a.dragNodesMixin; t.prototype.getSelectedParentNodes = function () { var e = []; return this.series.forEach(function (t) { t.parentNode && t.parentNode.selected && e.push(t.parentNode) }), e }, a.networkgraphIntegrations.packedbubble = { repulsiveForceFunction: function (t, e, i, o) { return Math.min(t, (i.marker.radius + o.marker.radius) / 2) }, barycenter: function () { var e, i, o = this, s = o.options.gravitationalConstant, a = o.box, r = o.nodes; r.forEach(function (t) { i = o.options.splitSeries && !t.isParentNode ? (e = t.series.parentNode.plotX, t.series.parentNode.plotY) : (e = a.width / 2, a.height / 2), t.fixedPosition || (t.plotX -= (t.plotX - e) * s / (t.mass * Math.sqrt(r.length)), t.plotY -= (t.plotY - i) * s / (t.mass * Math.sqrt(r.length))) }) }, repulsive: function (t, e, i, o) { var s = e * this.diffTemperature / t.mass / t.degree; e = i.x * s, i = i.y * s, t.fixedPosition || (t.plotX += e, t.plotY += i), o.fixedPosition || (o.plotX -= e, o.plotY -= i) }, integrate: a.networkgraphIntegrations.verlet.integrate, getK: a.noop }, a.layouts.packedbubble = e(b, { beforeStep: function () { this.options.marker && this.series.forEach(function (t) { t && t.calculateParentRadius() }) }, setCircularPositions: function () { var i, o, s = this, a = s.box, t = s.nodes, r = 2 * Math.PI / (t.length + 1), n = s.options.initialPositionRadius; t.forEach(function (t, e) { o = s.options.splitSeries && !t.isParentNode ? (i = t.series.parentNode.plotX, t.series.parentNode.plotY) : (i = a.width / 2, a.height / 2), t.plotX = t.prevX = u(t.plotX, i + n * Math.cos(t.index || e * r)), t.plotY = t.prevY = u(t.plotY, o + n * Math.sin(t.index || e * r)), t.dispX = 0, t.dispY = 0 }) }, repulsiveForces: function () { var i, o, s, a = this, r = a.options.bubblePadding; a.nodes.forEach(function (e) { e.degree = e.mass, e.neighbours = 0, a.nodes.forEach(function (t) { i = 0, e === t || e.fixedPosition || !a.options.seriesInteraction && e.series !== t.series || (s = a.getDistXY(e, t), (o = a.vectorLength(s) - (e.marker.radius + t.marker.radius + r)) < 0 && (e.degree += .01, e.neighbours++, i = a.repulsiveForce(-o / Math.sqrt(e.neighbours), a.k, e, t)), a.force("repulsive", e, i * t.mass, s, t, o)) }) }) }, applyLimitBox: function (t) { var e, i; this.options.splitSeries && !t.isParentNode && this.options.parentNodeLimit && (e = this.getDistXY(t, t.series.parentNode), (i = t.series.parentNodeRadius - t.marker.radius - this.vectorLength(e)) < 0 && i > -2 * t.marker.radius && (t.plotX -= .01 * e.x, t.plotY -= .01 * e.y)), b.prototype.applyLimitBox.apply(this, arguments) } }), i("packedbubble", "bubble", { minSize: "10%", maxSize: "50%", sizeBy: "area", zoneAxis: "y", crisp: !1, tooltip: { pointFormat: "Value: {point.value}" }, draggable: !0, useSimulation: !0, parentNode: { allowPointSelect: !1 }, dataLabels: { formatter: function () { return this.point.value }, parentNodeFormatter: function () { return this.name }, parentNodeTextPath: { enabled: !0 }, padding: 0, style: { transition: "opacity 2000ms" } }, layoutAlgorithm: { initialPositions: "circle", initialPositionRadius: 20, bubblePadding: 5, parentNodeLimit: !1, seriesInteraction: !0, dragBetweenSeries: !1, parentNodeOptions: { maxIterations: 400, gravitationalConstant: .03, maxSpeed: 50, initialPositionRadius: 100, seriesInteraction: !0, marker: { fillColor: null, fillOpacity: 1, lineWidth: 1, lineColor: null, symbol: "circle" } }, enableSimulation: !0, type: "packedbubble", integration: "packedbubble", maxIterations: 1e3, splitSeries: !1, maxSpeed: 5, gravitationalConstant: .01, friction: -.981 } }, { hasDraggableNodes: !0, forces: ["barycenter", "repulsive"], pointArrayMap: ["value"], trackerGroups: ["group", "dataLabelsGroup", "parentNodesGroup"], pointValKey: "value", isCartesian: !1, requireSorting: !1, directTouch: !0, axisTypes: [], noSharedTooltip: !0, searchPoint: a.noop, accumulateAllPoints: function (t) { for (var e, i = t.chart, o = [], s = 0; s < i.series.length; s++)if ((t = i.series[s]).is("packedbubble") && t.visible || !i.options.chart.ignoreHiddenSeries) for (e = 0; e < t.yData.length; e++)o.push([null, null, t.yData[e], t.index, e, { id: e, marker: { radius: 0 } }]); return o }, init: function () { return f.prototype.init.apply(this, arguments), s(this, "updatedData", function () { this.chart.series.forEach(function (t) { t.type === this.type && (t.isDirty = !0) }, this) }), this }, render: function () { var e = []; f.prototype.render.apply(this, arguments), this.options.dataLabels.allowOverlap || (this.data.forEach(function (t) { n(t.dataLabels) && t.dataLabels.forEach(function (t) { e.push(t) }) }), this.options.useSimulation && this.chart.hideOverlappingLabels(e)) }, setVisible: function () { var e = this; f.prototype.setVisible.apply(e, arguments), e.parentNodeLayout && e.graph ? e.visible ? (e.graph.show(), e.parentNode.dataLabel && e.parentNode.dataLabel.show()) : (e.graph.hide(), e.parentNodeLayout.removeElementFromCollection(e.parentNode, e.parentNodeLayout.nodes), e.parentNode.dataLabel && e.parentNode.dataLabel.hide()) : e.layout && (e.visible ? e.layout.addElementsToCollection(e.points, e.layout.nodes) : e.points.forEach(function (t) { e.layout.removeElementFromCollection(t, e.layout.nodes) })) }, drawDataLabels: function () { var t = this.options.dataLabels.textPath, e = this.points; f.prototype.drawDataLabels.apply(this, arguments), this.parentNode && (this.parentNode.formatPrefix = "parentNode", this.points = [this.parentNode], this.options.dataLabels.textPath = this.options.dataLabels.parentNodeTextPath, f.prototype.drawDataLabels.apply(this, arguments), this.points = e, this.options.dataLabels.textPath = t) }, seriesBox: function () { var e, t = this.chart, i = Math.max, o = Math.min, s = [t.plotLeft, t.plotLeft + t.plotWidth, t.plotTop, t.plotTop + t.plotHeight]; return this.data.forEach(function (t) { h(t.plotX) && h(t.plotY) && t.marker.radius && (e = t.marker.radius, s[0] = o(s[0], t.plotX - e), s[1] = i(s[1], t.plotX + e), s[2] = o(s[2], t.plotY - e), s[3] = i(s[3], t.plotY + e)) }), d(s.width / s.height) ? s : null }, calculateParentRadius: function () { var t = this.seriesBox(); this.parentNodeRadius = g(Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20, 20, t ? Math.max(Math.sqrt(Math.pow(t.width, 2) + Math.pow(t.height, 2)) / 2 + 20, 20) : Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20), this.parentNode && (this.parentNode.marker.radius = this.parentNode.radius = this.parentNodeRadius) }, drawGraph: function () { var t, e, i; this.layout && this.layout.options.splitSeries && (t = this.chart, e = { fill: (e = this.layout.options.parentNodeOptions.marker).fillColor || o(this.color).brighten(.4).get(), opacity: e.fillOpacity, stroke: e.lineColor || this.color, "stroke-width": e.lineWidth }, i = this.visible ? "inherit" : "hidden", this.parentNodesGroup || (this.parentNodesGroup = this.plotGroup("parentNodesGroup", "parentNode", i, .1, t.seriesGroup), this.group.attr({ zIndex: 2 })), this.calculateParentRadius(), i = c({ x: this.parentNode.plotX - this.parentNodeRadius, y: this.parentNode.plotY - this.parentNodeRadius, width: 2 * this.parentNodeRadius, height: 2 * this.parentNodeRadius }, e), this.parentNode.graphic || (this.graph = this.parentNode.graphic = t.renderer.symbol(e.symbol).add(this.parentNodesGroup)), this.parentNode.graphic.attr(i)) }, createParentNodes: function () { var e, i = this, t = i.chart, o = i.parentNodeLayout, s = i.parentNode, a = i.pointClass; i.parentNodeMass = 0, i.points.forEach(function (t) { i.parentNodeMass += Math.PI * Math.pow(t.marker.radius, 2) }), i.calculateParentRadius(), o.nodes.forEach(function (t) { t.seriesIndex === i.index && (e = !0) }), o.setArea(0, 0, t.plotWidth, t.plotHeight), e || (s = s || (new a).init(this, { mass: i.parentNodeRadius / 2, marker: { radius: i.parentNodeRadius }, dataLabels: { inside: !1 }, dataLabelOnNull: !0, degree: i.parentNodeRadius, isParentNode: !0, seriesIndex: i.index }), i.parentNode && (s.plotX = i.parentNode.plotX, s.plotY = i.parentNode.plotY), i.parentNode = s, o.addElementsToCollection([i], o.series), o.addElementsToCollection([s], o.nodes)) }, drawTracker: function () { var t, e = this.parentNode; a.TrackerMixin.drawTrackerPoint.call(this), e && (t = n(e.dataLabels) ? e.dataLabels : e.dataLabel ? [e.dataLabel] : [], e.graphic && (e.graphic.element.point = e), t.forEach(function (t) { t.div ? t.div.point = e : t.element.point = e })) }, addSeriesLayout: function () { var t = this.options.layoutAlgorithm, e = this.chart.graphLayoutsStorage, i = this.chart.graphLayoutsLookup, o = c(t, t.parentNodeOptions, { enableSimulation: this.layout.options.enableSimulation }), s = e[t.type + "-series"]; s || (e[t.type + "-series"] = s = new a.layouts[t.type], s.init(o), i.splice(s.index, 0, s)), this.parentNodeLayout = s, this.createParentNodes() }, addLayout: function () { var t = this.options.layoutAlgorithm, e = this.chart.graphLayoutsStorage, i = this.chart.graphLayoutsLookup, o = this.chart.options.chart; e || (this.chart.graphLayoutsStorage = e = {}, this.chart.graphLayoutsLookup = i = []); var s = e[t.type]; s || (t.enableSimulation = h(o.forExport) ? !o.forExport : t.enableSimulation, e[t.type] = s = new a.layouts[t.type], s.init(t), i.splice(s.index, 0, s)), this.layout = s, this.points.forEach(function (t) { t.mass = 2, t.degree = 1, t.collisionNmb = 1 }), s.setArea(0, 0, this.chart.plotWidth, this.chart.plotHeight), s.addElementsToCollection([this], s.series), s.addElementsToCollection(this.points, s.nodes) }, deferLayout: function () { var t = this.options.layoutAlgorithm; this.visible && (this.addLayout(), t.splitSeries && this.addSeriesLayout()) }, translate: function () { var t, e, i, o, s = this.chart, a = this.data, r = this.index, n = this.options.useSimulation; for (this.processedXData = this.xData, this.generatePoints(), h(s.allDataPoints) || (s.allDataPoints = this.accumulateAllPoints(this), this.getPointRadius()), n ? e = s.allDataPoints : (e = this.placeBubbles(s.allDataPoints), this.options.draggable = !1), t = 0; t < e.length; t++) { e[t][3] === r && (i = a[e[t][4]], o = e[t][2], n || (i.plotX = e[t][0] - s.plotLeft + s.diffX, i.plotY = e[t][1] - s.plotTop + s.diffY), i.marker = l(i.marker, { radius: o, width: 2 * o, height: 2 * o }), i.radius = o) } n && this.deferLayout(), p(this, "afterTranslate") }, checkOverlap: function (t, e) { var i = t[0] - e[0], o = t[1] - e[1]; return Math.sqrt(i * i + o * o) - Math.abs(t[2] + e[2]) < -.001 }, positionBubble: function (t, e, i) { var o = Math.sqrt, s = Math.asin, a = Math.acos, r = Math.pow, n = Math.abs, o = o(r(t[0] - e[0], 2) + r(t[1] - e[1], 2)), a = a((r(o, 2) + r(i[2] + e[2], 2) - r(i[2] + t[2], 2)) / (2 * (i[2] + e[2]) * o)), s = s(n(t[0] - e[0]) / o); return t = (t[1] - e[1] < 0 ? 0 : Math.PI) + a + s * ((t[0] - e[0]) * (t[1] - e[1]) < 0 ? 1 : -1), [e[0] + (e[2] + i[2]) * Math.sin(t), e[1] - (e[2] + i[2]) * Math.cos(t), i[2], i[3], i[4]] }, placeBubbles: function (t) { var e, i = this.checkOverlap, o = this.positionBubble, s = [], a = 1, r = 0, n = 0, h = []; if ((t = t.sort(function (t, e) { return e[2] - t[2] })).length) { if (s.push([[0, 0, t[0][2], t[0][3], t[0][4]]]), 1 < t.length) for (s.push([[0, 0 - t[1][2] - t[0][2], t[1][2], t[1][3], t[1][4]]]), e = 2; e < t.length; e++)t[e][2] = t[e][2] || 1, i(h = o(s[a][r], s[a - 1][n], t[e]), s[a][0]) ? (s.push([]), n = 0, s[a + 1].push(o(s[a][r], s[a][0], t[e])), a++, r = 0) : 1 < a && s[a - 1][n + 1] && i(h, s[a - 1][n + 1]) ? (n++, s[a].push(o(s[a][r], s[a - 1][n], t[e])), r++) : (r++, s[a].push(h)); this.chart.stages = s, this.chart.rawPositions = [].concat.apply([], s), this.resizeRadius(), h = this.chart.rawPositions } return h }, resizeRadius: function () { for (var t = this.chart, e = t.rawPositions, i = Math.min, o = Math.max, s = t.plotLeft, a = t.plotTop, r = t.plotHeight, n = t.plotWidth, h = c = Number.POSITIVE_INFINITY, l = u = Number.NEGATIVE_INFINITY, p = 0; p < e.length; p++)var d = e[p][2], h = i(h, e[p][0] - d), l = o(l, e[p][0] + d), c = i(c, e[p][1] - d), u = o(u, e[p][1] + d); if (p = [l - h, u - c], i = i.apply([], [(n - s) / p[0], (r - a) / p[1]]), 1e-10 < Math.abs(i - 1)) { for (p = 0; p < e.length; p++)e[p][2] *= i; this.placeBubbles(e) } else t.diffY = r / 2 + a - c - (u - c) / 2, t.diffX = n / 2 + s - h - (l - h) / 2 }, calculateZExtremes: function () { var t = this.options.zMin, e = this.options.zMax, i = 1 / 0, o = -1 / 0; return t && e ? [t, e] : (this.chart.series.forEach(function (t) { t.yData.forEach(function (t) { h(t) && (o < t && (o = t), t < i && (i = t)) }) }), [t = u(t, i), e = u(e, o)]) }, getPointRadius: function () { var i, o, s, a, r = this, t = r.chart, n = r.options, h = n.useSimulation, l = Math.min(t.plotWidth, t.plotHeight), p = {}, d = [], c = t.allDataPoints;["minSize", "maxSize"].forEach(function (t) { var e = parseInt(n[t], 10), i = /%$/.test(n[t]); p[t] = i ? l * e / 100 : e * Math.sqrt(c.length) }), t.minRadius = i = p.minSize / Math.sqrt(c.length), t.maxRadius = o = p.maxSize / Math.sqrt(c.length); var u = h ? r.calculateZExtremes() : [i, o]; (c || []).forEach(function (t, e) { s = h ? g(t[2], u[0], u[1]) : t[2], 0 === (a = r.getRadius(u[0], u[1], i, o, s)) && (a = null), c[e][2] = a, d.push(a) }), r.radii = d }, redrawHalo: m.redrawHalo, onMouseDown: m.onMouseDown, onMouseMove: m.onMouseMove, onMouseUp: function (e) { var i, o, t; e.fixedPosition && !e.removed && (o = this.layout, (t = this.parentNodeLayout) && o.options.dragBetweenSeries && t.nodes.forEach(function (t) { e && e.marker && t !== e.series.parentNode && (i = o.getDistXY(e, t), o.vectorLength(i) - t.marker.radius - e.marker.radius < 0 && (t.series.addPoint(c(e.options, { plotX: e.plotX, plotY: e.plotY }), !1), o.removeElementFromCollection(e, o.nodes), e.remove())) }), m.onMouseUp.apply(this, arguments)) }, destroy: function () { this.chart.graphLayoutsLookup && this.chart.graphLayoutsLookup.forEach(function (t) { t.removeElementFromCollection(this, t.series) }, this), this.parentNode && (this.parentNodeLayout.removeElementFromCollection(this.parentNode, this.parentNodeLayout.nodes), this.parentNode.dataLabel && (this.parentNode.dataLabel = this.parentNode.dataLabel.destroy())), a.Series.prototype.destroy.apply(this, arguments) }, alignDataLabel: a.Series.prototype.alignDataLabel }, { destroy: function () { return this.series.layout && this.series.layout.removeElementFromCollection(this, this.series.layout.nodes), r.prototype.destroy.apply(this, arguments) }, firePointEvent: function (t, e, i) { var o, s = this.series.options; this.isParentNode && s.parentNode ? (o = s.allowPointSelect, s.allowPointSelect = s.parentNode.allowPointSelect, r.prototype.firePointEvent.apply(this, arguments), s.allowPointSelect = o) : r.prototype.firePointEvent.apply(this, arguments) }, select: function (t, e) { var i = this.series.chart; this.isParentNode ? (i.getSelectedPoints = i.getSelectedParentNodes, r.prototype.select.apply(this, arguments), i.getSelectedPoints = a.Chart.prototype.getSelectedPoints) : r.prototype.select.apply(this, arguments) } }), s(t, "beforeRedraw", function () { this.allDataPoints && delete this.allDataPoints }) }), e(t, "Extensions/Polar.js", [t["Core/Chart/Chart.js"], t["Core/Globals.js"], t["Extensions/Pane.js"], t["Core/Pointer.js"], t["Core/Renderer/SVG/SVGRenderer.js"], t["Core/Utilities.js"]], function (t, f, e, i, o, y) { var s = y.addEvent, b = y.animObject, v = y.defined, a = y.find, x = y.isNumber, m = y.pick, r = y.splat, n = y.uniqueKey, h = y.wrap, l = f.Series, p = f.seriesTypes, d = l.prototype; i = i.prototype, d.searchPointByAngle = function (t) { var e = this.chart, i = this.xAxis.pane.center; return this.searchKDTree({ clientX: 180 + -180 / Math.PI * Math.atan2(t.chartX - i[0] - e.plotLeft, t.chartY - i[1] - e.plotTop) }) }, d.getConnectors = function (t, e, i, o) { var s = o ? 1 : 0, a = 0 <= e && e <= t.length - 1 ? e : e < 0 ? t.length - 1 + e : 0; e = a - 1 < 0 ? t.length - (1 + s) : a - 1, s = a + 1 > t.length - 1 ? s : a + 1; var r = t[e], s = t[s], n = r.plotX, r = r.plotY, h = s.plotX, l = s.plotY; n = (1.5 * (s = t[a].plotX) + n) / 2.5, r = (1.5 * (a = t[a].plotY) + r) / 2.5, h = (1.5 * s + h) / 2.5; var p = (1.5 * a + l) / 2.5, l = Math.sqrt(Math.pow(n - s, 2) + Math.pow(r - a, 2)), d = Math.sqrt(Math.pow(h - s, 2) + Math.pow(p - a, 2)), n = Math.atan2(r - a, n - s), p = Math.PI / 2 + (n + Math.atan2(p - a, h - s)) / 2; return Math.abs(n - p) > Math.PI / 2 && (p -= Math.PI), n = s + Math.cos(p) * l, r = a + Math.sin(p) * l, s = { rightContX: h = s + Math.cos(Math.PI + p) * d, rightContY: p = a + Math.sin(Math.PI + p) * d, leftContX: n, leftContY: r, plotX: s, plotY: a }, i && (s.prevPointCont = this.getConnectors(t, e, !1, o)), s }, d.toXY = function (t) { var e = this.chart, i = this.xAxis, o = this.yAxis, s = t.plotX, a = t.plotY, r = t.series, n = e.inverted, h = t.y, l = n ? s : o.len - a; n && r && !r.isRadialBar && (t.plotY = a = "number" == typeof h && o.translate(h) || 0), t.rectPlotX = s, t.rectPlotY = a, o.center && (l += o.center[3] / 2), o = n ? o.postTranslate(a, l) : i.postTranslate(s, l), t.plotX = t.polarPlotX = o.x - e.plotLeft, t.plotY = t.polarPlotY = o.y - e.plotTop, this.kdByAngle ? ((e = (s / Math.PI * 180 + i.pane.options.startAngle) % 360) < 0 && (e += 360), t.clientX = e) : t.clientX = t.plotX }, p.spline && (h(p.spline.prototype, "getPointSpline", function (t, e, i, o) { return t = this.chart.polar ? o ? ["C", (t = this.getConnectors(e, o, !0, this.connectEnds)).prevPointCont.rightContX, t.prevPointCont.rightContY, t.leftContX, t.leftContY, t.plotX, t.plotY] : ["M", i.plotX, i.plotY] : t.call(this, e, i, o) }), p.areasplinerange && (p.areasplinerange.prototype.getPointSpline = p.spline.prototype.getPointSpline)), s(l, "afterTranslate", function () { var e = this.chart; if (e.polar && this.xAxis) { if ((this.kdByAngle = e.tooltip && e.tooltip.shared) ? this.searchPoint = this.searchPointByAngle : this.options.findNearestPointBy = "xy", !this.preventPostTranslate) for (var t = this.points, i = t.length; i--;)this.toXY(t[i]), !e.hasParallelCoordinates && !this.yAxis.reversed && t[i].y < this.yAxis.min && (t[i].isNull = !0); this.hasClipCircleSetter || (this.hasClipCircleSetter = !!this.eventsToUnbind.push(s(this, "afterRender", function () { var t; e.polar && (t = this.yAxis.pane.center, this.clipCircle ? this.clipCircle.animate({ x: t[0], y: t[1], r: t[2] / 2, innerR: t[3] / 2 }) : this.clipCircle = e.renderer.clipCircle(t[0], t[1], t[2] / 2, t[3] / 2), this.group.clip(this.clipCircle), this.setClip = f.noop) }))) } }, { order: 2 }), h(d, "getGraphPath", function (t, e) { var i, o, s = this; if (this.chart.polar) { for (e = e || this.points, i = 0; i < e.length; i++)if (!e[i].isNull) { var a = i; break } !1 !== this.options.connectEnds && void 0 !== a && (this.connectEnds = !0, e.splice(e.length, 0, e[a]), o = !0), e.forEach(function (t) { void 0 === t.polarPlotY && s.toXY(t) }) } return i = t.apply(this, [].slice.call(arguments, 1)), o && e.pop(), i }); function c(t, e) { var i, o, s, a, r, n = this, h = this.chart, l = this.options.animation, p = this.group, d = this.markerGroup, c = this.xAxis.center, u = h.plotLeft, g = h.plotTop; h.polar ? n.isRadialBar ? e || (n.startAngleRad = m(n.translatedThreshold, n.xAxis.startAngleRad), f.seriesTypes.pie.prototype.animate.call(n, e)) : h.renderer.isSVG && (l = b(l), n.is("column") ? e || (r = c[3] / 2, n.points.forEach(function (t) { i = t.graphic, s = (o = t.shapeArgs) && o.r, a = o && o.innerR, i && o && (i.attr({ r: r, innerR: r }), i.animate({ r: s, innerR: a }, n.options.animation)) })) : e ? (t = { translateX: c[0] + u, translateY: c[1] + g, scaleX: .001, scaleY: .001 }, p.attr(t), d && d.attr(t)) : (t = { translateX: u, translateY: g, scaleX: 1, scaleY: 1 }, p.animate(t, l), d && d.animate(t, l))) : t.call(this, e) } h(d, "animate", c), p.column && (l = p.arearange.prototype, (p = p.column.prototype).polarArc = function (t, e, i, o) { var s = this.xAxis.center, a = this.yAxis.len, r = s[3] / 2; return e = a - e + r, t = a - m(t, a) + r, this.yAxis.reversed && (e < 0 && (e = r), t < 0 && (t = r)), { x: s[0], y: s[1], r: e, innerR: t, start: i, end: o } }, h(p, "animate", c), h(p, "translate", function (t) { var e = (c = this.options).stacking, i = this.chart, o = this.xAxis, s = this.yAxis, a = s.reversed, r = s.center, n = o.startAngleRad, h = o.endAngleRad - n; if (this.preventPostTranslate = !0, t.call(this), o.isRadial) { o = (t = this.points).length; var l, p = s.translate(s.min), d = s.translate(s.max), c = c.threshold || 0; for (i.inverted && x(c) && (l = s.translate(c), v(l) && (l < 0 ? l = 0 : h < l && (l = h), this.translatedThreshold = l + n)); o--;) { var u, g, f = (c = t[o]).barX, b = c.x, m = c.y; c.shapeType = "arc", i.inverted ? (c.plotY = s.translate(m), e && s.stacking ? (m = s.stacking.stacks[(m < 0 ? "-" : "") + this.stackKey], this.visible && m && m[b] && !c.isNull && (g = m[b].points[this.getStackIndicator(void 0, b, this.index).key], u = s.translate(g[0]), g = s.translate(g[1]), v(u) && (u = y.clamp(u, 0, h)))) : (u = l, g = c.plotY), g < u && (g = [u, u = g][0]), a ? p < g ? g = p : u < d ? u = d : (p < u || g < d) && (u = g = h) : u < p ? u = p : d < g ? g = d : (g < p || d < u) && (u = g = 0), s.min > s.max && (u = g = a ? h : 0), u += n, g += n, r && (c.barX = f += r[3] / 2), b = Math.max(f, 0), m = Math.max(f + c.pointWidth, 0), c.shapeArgs = { x: r && r[0], y: r && r[1], r: m, innerR: b, start: u, end: g }, c.opacity = u === g ? 0 : void 0, c.plotY = (v(this.translatedThreshold) && (u < this.translatedThreshold ? u : g)) - n) : (u = f + n, c.shapeArgs = this.polarArc(c.yBottom, c.plotY, u, u + c.pointWidth)), this.toXY(c), i.inverted ? (f = s.postTranslate(c.rectPlotY, f + c.pointWidth / 2), c.tooltipPos = [f.x - i.plotLeft, f.y - i.plotTop]) : c.tooltipPos = [c.plotX, c.plotY], r && (c.ttBelow = c.plotY > r[1]) } } }), p.findAlignments = function (t, e) { return null === e.align && (e.align = 20 < t && t < 160 ? "left" : 200 < t && t < 340 ? "right" : "center"), null === e.verticalAlign && (e.verticalAlign = t < 45 || 315 < t ? "bottom" : 135 < t && t < 225 ? "top" : "middle"), e }, l && (l.findAlignments = p.findAlignments), h(p, "alignDataLabel", function (t, e, i, o, s, a) { var r = this.chart, n = m(o.inside, !!this.options.stacking); r.polar ? (t = e.rectPlotX / Math.PI * 180, r.inverted ? (this.forceDL = r.isInsidePlot(e.plotX, Math.round(e.plotY), !1), n && e.shapeArgs ? (s = e.shapeArgs, s = { x: (s = this.yAxis.postTranslate((s.start + s.end) / 2 - this.xAxis.startAngleRad, e.barX + e.pointWidth / 2)).x - r.plotLeft, y: s.y - r.plotTop }) : e.tooltipPos && (s = { x: e.tooltipPos[0], y: e.tooltipPos[1] }), o.align = m(o.align, "center"), o.verticalAlign = m(o.verticalAlign, "middle")) : this.findAlignments && (o = this.findAlignments(t, o)), d.alignDataLabel.call(this, e, i, o, s, a), this.isRadialBar && e.shapeArgs && e.shapeArgs.start === e.shapeArgs.end && i.hide(!0)) : t.call(this, e, i, o, s, a) })), h(i, "getCoordinates", function (t, s) { var a = this.chart, r = { xAxis: [], yAxis: [] }; return a.polar ? a.axes.forEach(function (t) { var e, i = t.isXAxis, o = t.center; "colorAxis" !== t.coll && (e = s.chartX - o[0] - a.plotLeft, o = s.chartY - o[1] - a.plotTop, r[i ? "xAxis" : "yAxis"].push({ axis: t, value: t.translate(i ? Math.PI - Math.atan2(e, o) : Math.sqrt(Math.pow(e, 2) + Math.pow(o, 2)), !0) })) }) : r = t.call(this, s), r }), o.prototype.clipCircle = function (t, e, i, o) { var s = n(), a = this.createElement("clipPath").attr({ id: s }).add(this.defs); return (t = o ? this.arc(t, e, i, o, 0, 2 * Math.PI).add(a) : this.circle(t, e, i).add(a)).id = s, t.clipPath = a, t }, s(t, "getAxes", function () { this.pane || (this.pane = []), r(this.options.pane).forEach(function (t) { new e(t, this) }, this) }), s(t, "afterDrawChartBox", function () { this.pane.forEach(function (t) { t.render() }) }), s(f.Series, "afterInit", function () { var t = this.chart; t.inverted && t.polar && (this.isRadialSeries = !0, this.is("column") && (this.isRadialBar = !0)) }), h(t.prototype, "get", function (t, e) { return a(this.pane, function (t) { return t.options.id === e }) || t.call(this, e) }) }), e(t, "masters/highcharts-more.src.js", [], function () { }) });