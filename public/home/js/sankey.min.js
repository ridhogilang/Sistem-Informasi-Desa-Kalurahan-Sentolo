!function (t) { "object" == typeof module && module.exports ? module.exports = t.default = t : "function" == typeof define && define.amd ? define("highcharts/modules/sankey", ["highcharts"], function (o) { return t(o), t.Highcharts = o, t }) : t("undefined" != typeof Highcharts ? Highcharts : void 0) }(function (o) { function t(o, t, e, i) { o.hasOwnProperty(t) || (o[t] = i.apply(null, e)) } t(o = o ? o._modules : {}, "Mixins/Nodes.js", [o["Core/Globals.js"], o["Core/Series/Point.js"], o["Core/Utilities.js"]], function (o, i, t) { var n = t.defined, s = t.extend, r = t.find, a = t.pick; return o.NodesMixin = { createNode: function (o) { function t(o, t) { return r(o, function (o) { return o.id === t }) } var e, n = t(this.nodes, o), i = this.pointClass; return n || (e = this.options.nodes && t(this.options.nodes, o), (n = (new i).init(this, s({ className: "highcharts-node", isNode: !0, id: o, y: 1 }, e))).linksTo = [], n.linksFrom = [], n.formatPrefix = "node", n.name = n.name || n.options.id || "", n.mass = a(n.options.mass, n.options.marker && n.options.marker.radius, this.options.marker && this.options.marker.radius, 4), n.getSum = function () { var t = 0, e = 0; return n.linksTo.forEach(function (o) { t += o.weight }), n.linksFrom.forEach(function (o) { e += o.weight }), Math.max(t, e) }, n.offset = function (o, t) { for (var e = 0, i = 0; i < n[t].length; i++) { if (n[t][i] === o) return e; e += n[t][i].weight } }, n.hasShape = function () { var t = 0; return n.linksTo.forEach(function (o) { o.outgoing && t++ }), !n.linksTo.length || t !== n.linksTo.length }, this.nodes.push(n)), n }, generatePoints: function () { var t = this.chart, e = {}; o.Series.prototype.generatePoints.call(this), this.nodes || (this.nodes = []), this.colorCounter = 0, this.nodes.forEach(function (o) { o.linksFrom.length = 0, o.linksTo.length = 0, o.level = o.options.level }), this.points.forEach(function (o) { n(o.from) && (e[o.from] || (e[o.from] = this.createNode(o.from)), e[o.from].linksFrom.push(o), o.fromNode = e[o.from], t.styledMode ? o.colorIndex = a(o.options.colorIndex, e[o.from].colorIndex) : o.color = o.options.color || e[o.from].color), n(o.to) && (e[o.to] || (e[o.to] = this.createNode(o.to)), e[o.to].linksTo.push(o), o.toNode = e[o.to]), o.name = o.name || o.id }, this), this.nodeLookup = e }, setData: function () { this.nodes && (this.nodes.forEach(function (o) { o.destroy() }), this.nodes.length = 0), o.Series.prototype.setData.apply(this, arguments) }, destroy: function () { return this.data = [].concat(this.points || [], this.nodes), o.Series.prototype.destroy.apply(this, arguments) }, setNodeState: function (o) { var t = arguments, e = this.isNode ? this.linksTo.concat(this.linksFrom) : [this.fromNode, this.toNode]; "select" !== o && e.forEach(function (o) { o && o.series && (i.prototype.setState.apply(o, t), o.isNode || (o.fromNode.graphic && i.prototype.setState.apply(o.fromNode, t), o.toNode && o.toNode.graphic && i.prototype.setState.apply(o.toNode, t))) }), i.prototype.setState.apply(this, t) } } }), t(o, "Mixins/TreeSeries.js", [o["Core/Color.js"], o["Core/Utilities.js"]], function (m, o) { var d = o.extend, r = o.isArray, a = o.isNumber, l = o.isObject, h = o.merge, g = o.pick; return { getColor: function (o, t) { var e, i, n, s, r = t.index, a = t.mapOptionsToLevel, l = t.parentColor, h = t.parentColorIndex, d = t.series, c = t.colors, p = t.siblings, u = d.points, f = d.chart.options.chart; return o && (u = u[o.i], o = a[o.level] || {}, (a = u && o.colorByPoint) && (i = u.index % (c ? c.length : f.colorCount), n = c && c[i]), d.chart.styledMode || (c = u && u.options.color, f = o && o.color, (e = l) && (e = (e = o && o.colorVariation) && "brightness" === e.key ? m.parse(l).brighten(r / p * e.to).get() : l), e = g(c, f, n, e, d.color)), s = g(u && u.options.colorIndex, o && o.colorIndex, i, h, t.colorIndex)), { color: e, colorIndex: s } }, getLevelOptions: function (o) { var t = null; if (l(o)) { t = {}; var n = a(o.from) ? o.from : 1, e = o.levels, i = {}, s = l(o.defaults) ? o.defaults : {}; for (r(e) && (i = e.reduce(function (o, t) { var e, i; return l(t) && a(t.level) && (i = "boolean" == typeof (e = h({}, t)).levelIsConstant ? e.levelIsConstant : s.levelIsConstant, delete e.levelIsConstant, delete e.level, t = t.level + (i ? 0 : n - 1), l(o[t]) ? d(o[t], e) : o[t] = e), o }, {})), e = a(o.to) ? o.to : 1, o = 0; o <= e; o++)t[o] = h({}, s, l(i[o]) ? i[o] : {}) } return t }, setTreeValues: function i(n, s) { var o = s.before, t = s.idRoot, e = s.mapIdToNode[t], r = s.points[n.i], a = r && r.options || {}, l = 0, h = []; return d(n, { levelDynamic: n.level - ("boolean" != typeof s.levelIsConstant || s.levelIsConstant ? 0 : e.level), name: g(r && r.name, ""), visible: t === n.id || "boolean" == typeof s.visible && s.visible }), "function" == typeof o && (n = o(n, s)), n.children.forEach(function (o, t) { var e = d({}, s); d(e, { index: t, siblings: n.children.length, visible: n.visible }), o = i(o, e), h.push(o), o.visible && (l += o.val) }), n.visible = 0 < l || n.visible, o = g(a.value, l), d(n, { children: h, childrenTotal: l, isLeaf: n.visible && !l, val: o }), n }, updateRootId: function (o) { var t; return l(o) && (t = l(o.options) ? o.options : {}, t = g(o.rootNode, t.rootId, ""), l(o.userOptions) && (o.userOptions.rootId = t), o.rootNode = t), t } } }), t(o, "Series/SankeySeries.js", [o["Core/Globals.js"], o["Mixins/Nodes.js"], o["Core/Color.js"], o["Core/Series/Point.js"], o["Core/Utilities.js"], o["Mixins/TreeSeries.js"]], function (t, o, a, e, i, n) { var r = i.defined, l = i.find, h = i.isObject, d = i.merge, c = i.pick, p = i.relativeLength, s = i.seriesType, u = i.stableSort, f = n.getLevelOptions; s("sankey", "column", { borderWidth: 0, colorByPoint: !0, curveFactor: .33, dataLabels: { enabled: !0, backgroundColor: "none", crop: !1, nodeFormat: void 0, nodeFormatter: function () { return this.point.name }, format: void 0, formatter: function () { }, inside: !0 }, inactiveOtherPoints: !0, linkOpacity: .5, minLinkWidth: 0, nodeWidth: 20, nodePadding: 10, showInLegend: !1, states: { hover: { linkOpacity: 1 }, inactive: { linkOpacity: .1, opacity: .1, animation: { duration: 50 } } }, tooltip: { followPointer: !0, headerFormat: '<span style="font-size: 10px">{series.name}</span><br/>', pointFormat: "{point.fromNode.name} â†’ {point.toNode.name}: <b>{point.weight}</b><br/>", nodeFormat: "{point.name}: <b>{point.sum}</b><br/>" } }, { isCartesian: !1, invertable: !0, forceDL: !0, orderNodes: !0, pointArrayMap: ["from", "to"], createNode: o.createNode, searchPoint: t.noop, setData: o.setData, destroy: o.destroy, getNodePadding: function () { var o, t = this.options.nodePadding || 0; return !this.nodeColumns || (o = this.nodeColumns.reduce(function (o, t) { return Math.max(o, t.length) }, 0)) * t > this.chart.plotSizeY && (t = this.chart.plotSizeY / o), t }, createNodeColumn: function () { var a = this, t = this.chart, l = []; return l.sum = function () { return this.reduce(function (o, t) { return o + t.getSum() }, 0) }, l.offset = function (o, t) { for (var e = 0, i = a.nodePadding, n = 0; n < l.length; n++) { r = l[n].getSum(); var s = Math.max(r * t, a.options.minLinkWidth), r = r ? s + i : 0; if (l[n] === o) return { relativeTop: e + p(o.options.offset || 0, r) }; e += r } }, l.top = function (e) { var i = a.nodePadding, o = this.reduce(function (o, t) { return 0 < o && (o += i), o + (t = Math.max(t.getSum() * e, a.options.minLinkWidth)) }, 0); return (t.plotSizeY - o) / 2 }, l }, createNodeColumns: function () { var s = []; this.nodes.forEach(function (e) { var i, o = -1; if (!r(e.options.column)) if (0 === e.linksTo.length) e.column = 0; else { for (i = 0; i < e.linksTo.length; i++) { var t, n = e.linksTo[0]; n.fromNode.column > o && (o = (t = n.fromNode).column) } e.column = o + 1, t && "hanging" === t.options.layout && (e.hangsFrom = t, i = -1, l(t.linksFrom, function (o, t) { return (o = o.toNode === e) && (i = t), o }), e.column += i) } s[e.column] || (s[e.column] = this.createNodeColumn()), s[e.column].push(e) }, this); for (var o = 0; o < s.length; o++)void 0 === s[o] && (s[o] = this.createNodeColumn()); return s }, hasData: function () { return !!this.processedXData.length }, pointAttribs: function (o, t) { var e = this, i = e.mapOptionsToLevel[(o.isNode ? o.level : o.fromNode.level) || 0] || {}, n = o.options, s = i.states && i.states[t] || {}; t = ["colorByPoint", "borderColor", "borderWidth", "linkOpacity"].reduce(function (o, t) { return o[t] = c(s[t], n[t], i[t], e.options[t]), o }, {}); var r = c(s.color, n.color, t.colorByPoint ? o.color : i.color); return o.isNode ? { fill: r, stroke: t.borderColor, "stroke-width": t.borderWidth } : { fill: a.parse(r).setOpacity(t.linkOpacity).get() } }, generatePoints: function () { o.generatePoints.apply(this, arguments), this.orderNodes && (this.nodes.filter(function (o) { return 0 === o.linksTo.length }).forEach(function (o) { !function t(o, e) { void 0 === o.level && (o.level = e, o.linksFrom.forEach(function (o) { o.toNode && t(o.toNode, e + 1) })) }(o, 0) }), u(this.nodes, function (o, t) { return o.level - t.level })) }, translateNode: function (o, t) { var e = this.translationFactor, i = this.chart, n = this.options, s = o.getSum(), r = Math.max(Math.round(s * e), this.options.minLinkWidth), a = Math.round(n.borderWidth) % 2 / 2, l = t.offset(o, e); t = Math.floor(c(l.absoluteTop, t.top(e) + l.relativeTop)) + a, a = Math.floor(this.colDistance * o.column + n.borderWidth / 2) + a, a = i.inverted ? i.plotSizeX - a : a, e = Math.round(this.nodeWidth), (o.sum = s) ? (o.shapeType = "rect", o.nodeX = a, o.nodeY = t, o.shapeArgs = i.inverted ? { x: a - e, y: i.plotSizeY - t - r, width: o.options.height || n.height || e, height: o.options.width || n.width || r } : { x: a, y: t, width: o.options.width || n.width || e, height: o.options.height || n.height || r }, o.shapeArgs.display = o.hasShape() ? "" : "none", n = this.mapOptionsToLevel[o.level], s = o.options, s = h(s) ? s.dataLabels : {}, n = h(n) ? n.dataLabels : {}, n = d({ style: {} }, n, s), o.dlOptions = n, o.plotY = 1, o.tooltipPos = i.inverted ? [i.plotSizeY - o.shapeArgs.y - o.shapeArgs.height / 2, i.plotSizeX - o.shapeArgs.x - o.shapeArgs.width / 2] : [o.shapeArgs.x + o.shapeArgs.width / 2, o.shapeArgs.y + o.shapeArgs.height / 2]) : o.dlOptions = { enabled: !1 } }, translateLink: function (i) { var o, t, e, n, s, r, a, l, h, d, c, p, u, f = function (o, t) { var e; return t = o.offset(i, t) * y, Math.min(o.nodeY + t, o.nodeY + (null === (e = o.shapeArgs) || void 0 === e ? void 0 : e.height) - k) }, m = i.fromNode, g = i.toNode, v = this.chart, y = this.translationFactor, k = Math.max(i.weight * y, this.options.minLinkWidth), b = (v.inverted ? -this.colDistance : this.colDistance) * this.options.curveFactor, N = f(m, "linksFrom"), f = f(g, "linksTo"), C = m.nodeX, S = this.nodeWidth, g = g.column * this.colDistance, x = i.outgoing, L = C + S < g; v.inverted && (N = v.plotSizeY - N, f = (v.plotSizeY || 0) - f, g = v.plotSizeX - g, S = -S, k = -k, L = g < C), i.shapeType = "path", i.linkBase = [N, N + k, f, f + k], L && "number" == typeof f ? i.shapeArgs = { d: [["M", C + S, N], ["C", C + S + b, N, g - b, f, g, f], ["L", g + (x ? S : 0), f + k / 2], ["L", g, f + k], ["C", g - b, f + k, C + S + b, N + k, C + S, N + k], ["Z"]] } : "number" == typeof f && (b = g - 20 - k, x = g - 20, L = g, e = (t = (o = C + S) + 20) + k, l = (a = (r = (s = (n = N + k) + 20) + (v.plotHeight - N - k)) + 20) + k, d = (h = f + k) + 20, c = a + .7 * k, p = L - .7 * k, u = o + .7 * k, i.shapeArgs = { d: [["M", o, N], ["C", u, N, e, n - .7 * k, e, s], ["L", e, r], ["C", e, c, u, l, o, l], ["L", L, l], ["C", p, l, b, c, b, r], ["L", b, d], ["C", b, h - .7 * k, p, f, L, f], ["L", L, h], ["C", x, h, x, h, x, d], ["L", x, r], ["C", x, a, x, a, L, a], ["L", o, a], ["C", t, a, t, a, t, r], ["L", t, s], ["C", t, n, t, n, o, n], ["Z"]] }), i.dlBox = { x: C + (g - C + S) / 2, y: N + (f - N) / 2, height: k, width: 0 }, i.tooltipPos = v.inverted ? [v.plotSizeY - i.dlBox.y - k / 2, v.plotSizeX - i.dlBox.x] : [i.dlBox.x, i.dlBox.y + k / 2], i.y = i.plotY = 1, i.color || (i.color = m.color) }, translate: function () { var a = this; this.processedXData || this.processData(), this.generatePoints(), this.nodeColumns = this.createNodeColumns(), this.nodeWidth = p(this.options.nodeWidth, this.chart.plotSizeX); var l = this, h = this.chart, d = this.options, o = this.nodeWidth, t = this.nodeColumns; this.nodePadding = this.getNodePadding(), this.translationFactor = t.reduce(function (o, t) { return Math.min(o, function (t) { for (var o, e, i = t.slice(), n = a.options.minLinkWidth || 0, s = 0, r = h.plotSizeY - d.borderWidth - (t.length - 1) * l.nodePadding; t.length;) { for (s = r / t.sum(), o = !1, e = t.length; e--;)t[e].getSum() * s < n && (t.splice(e, 1), r -= n, o = !0); if (!o) break } return t.length = 0, i.forEach(function (o) { return t.push(o) }), s }(t)) }, 1 / 0), this.colDistance = (h.plotSizeX - o - d.borderWidth) / Math.max(1, t.length - 1), l.mapOptionsToLevel = f({ from: 1, levels: d.levels, to: t.length - 1, defaults: { borderColor: d.borderColor, borderRadius: d.borderRadius, borderWidth: d.borderWidth, color: l.color, colorByPoint: d.colorByPoint, levelIsConstant: !0, linkColor: d.linkColor, linkLineWidth: d.linkLineWidth, linkOpacity: d.linkOpacity, states: d.states } }), t.forEach(function (t) { t.forEach(function (o) { l.translateNode(o, t) }) }, this), this.nodes.forEach(function (o) { o.linksFrom.forEach(function (o) { (o.weight || o.isNull) && o.to && (l.translateLink(o), o.allowShadow = !1) }) }) }, render: function () { var o = this.points; this.points = this.points.concat(this.nodes || []), t.seriesTypes.column.prototype.render.call(this), this.points = o }, animate: t.Series.prototype.animate }, { applyOptions: function (o, t) { return e.prototype.applyOptions.call(this, o, t), r(this.options.level) && (this.options.column = this.column = this.options.level), this }, setState: o.setNodeState, getClassName: function () { return (this.isNode ? "highcharts-node " : "highcharts-link ") + e.prototype.getClassName.call(this) }, isValid: function () { return this.isNode || "number" == typeof this.weight } }) }), t(o, "masters/modules/sankey.src.js", [], function () { }) });