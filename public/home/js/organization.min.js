!function (e) { "object" == typeof module && module.exports ? module.exports = e.default = e : "function" == typeof define && define.amd ? define("highcharts/modules/organization", ["highcharts", "highcharts/modules/sankey"], function (t) { return e(t), e.Highcharts = t, e }) : e("undefined" != typeof Highcharts ? Highcharts : void 0) }(function (t) { function e(t, e, i, n) { t.hasOwnProperty(e) || (t[e] = n.apply(null, i)) } e(t = t ? t._modules : {}, "Series/OrganizationSeries.js", [t["Core/Globals.js"], t["Core/Utilities.js"]], function (r, t) { var h = t.css, a = t.pick, e = t.seriesType, i = t.wrap, p = r.seriesTypes.sankey.prototype; e("organization", "sankey", { borderColor: "#666666", borderRadius: 3, linkRadius: 10, borderWidth: 1, dataLabels: { nodeFormatter: function () { function t(i) { return Object.keys(i).reduce(function (t, e) { return t + e + ":" + i[e] + ";" }, 'style="') + '"' } var e = { width: "100%", height: "100%", display: "flex", "flex-direction": "row", "align-items": "center", "justify-content": "center" }, i = { "max-height": "100%", "border-radius": "50%" }, n = { width: "100%", padding: 0, "text-align": "center", "white-space": "normal" }; return this.point.image && (i["max-width"] = "30%", n.width = "70%"), this.series.chart.renderer.forExport && (e.display = "block", n.position = "absolute", n.left = this.point.image ? "30%" : 0, n.top = 0), e = "<div " + t(e) + ">", this.point.image && (e += '<img src="' + this.point.image + '" ' + t(i) + ">"), e += "<div " + t(n) + ">", this.point.name && (e += "<h4 " + t({ margin: 0 }) + ">" + this.point.name + "</h4>"), this.point.title && (e += "<p " + t({ margin: 0 }) + ">" + (this.point.title || "") + "</p>"), this.point.description && (e += "<p " + t({ opacity: .75, margin: "5px" }) + ">" + this.point.description + "</p>"), e + "</div></div>" }, style: { fontWeight: "normal", fontSize: "13px" }, useHTML: !0 }, hangingIndent: 20, linkColor: "#666666", linkLineWidth: 1, nodeWidth: 50, tooltip: { nodeFormat: "{point.name}<br>{point.title}<br>{point.description}" } }, { pointAttribs: function (t, e) { var i = this, n = p.pointAttribs.call(i, t, e), s = i.mapOptionsToLevel[(t.isNode ? t.level : t.fromNode.level) || 0] || {}, o = t.options, r = s.states && s.states[e] || {}; return e = ["borderRadius", "linkColor", "linkLineWidth"].reduce(function (t, e) { return t[e] = a(r[e], o[e], s[e], i.options[e]), t }, {}), t.isNode ? e.borderRadius && (n.r = e.borderRadius) : (n.stroke = e.linkColor, n["stroke-width"] = e.linkLineWidth, delete n.fill), n }, createNode: function (t) { return (t = p.createNode.call(this, t)).getSum = function () { return 1 }, t }, createNodeColumn: function () { var t = p.createNodeColumn.call(this); return i(t, "offset", function (t, e, i) { return t = t.call(this, e, i), e.hangsFrom ? { absoluteTop: e.hangsFrom.nodeY } : t }), t }, translateNode: function (t, e) { p.translateNode.call(this, t, e), t.hangsFrom && (t.shapeArgs.height -= this.options.hangingIndent, this.chart.inverted || (t.shapeArgs.y += this.options.hangingIndent)), t.nodeHeight = this.chart.inverted ? t.shapeArgs.width : t.shapeArgs.height }, curvedPath: function (t, e) { for (var i = [], n = 0; n < t.length; n++) { var s, o, r, h, a, p, d = t[n][1], l = t[n][2]; "number" == typeof d && "number" == typeof l && (0 === n ? i.push(["M", d, l]) : n !== t.length - 1 && e ? (o = t[n - 1], p = t[n + 1], o && p && (s = o[1], o = o[2], r = p[1], p = p[2], "number" == typeof s && "number" == typeof r && "number" == typeof o && "number" == typeof p && s !== r && o !== p && (h = s < r ? 1 : -1, a = o < p ? 1 : -1, i.push(["L", d - h * Math.min(Math.abs(d - s), e), l - a * Math.min(Math.abs(l - o), e)], ["C", d, l, d, l, d + h * Math.min(Math.abs(d - r), e), l + a * Math.min(Math.abs(l - p), e)])))) : i.push(["L", d, l])) } return i }, translateLink: function (t) { var e = t.fromNode, i = t.toNode, n = Math.round(this.options.linkLineWidth) % 2 / 2, s = Math.floor(e.shapeArgs.x + e.shapeArgs.width) + n, o = Math.floor(e.shapeArgs.y + e.shapeArgs.height / 2) + n, r = Math.floor(i.shapeArgs.x) + n, h = Math.floor(i.shapeArgs.y + i.shapeArgs.height / 2) + n, a = this.options.hangingIndent, p = i.options.offset, d = /%$/.test(p) && parseInt(p, 10), l = this.chart.inverted; l && (s -= e.shapeArgs.width, r += i.shapeArgs.width), p = Math.floor(r + (l ? 1 : -1) * (this.colDistance - this.nodeWidth) / 2) + n, d && (50 <= d || d <= -50) && (p = r = Math.floor(r + (l ? -.5 : .5) * i.shapeArgs.width) + n, h = i.shapeArgs.y, 0 < d && (h += i.shapeArgs.height)), i.hangsFrom === e && (this.chart.inverted ? (o = Math.floor(e.shapeArgs.y + e.shapeArgs.height - a / 2) + n, h = i.shapeArgs.y + i.shapeArgs.height) : o = Math.floor(e.shapeArgs.y + a / 2) + n, p = r = Math.floor(i.shapeArgs.x + i.shapeArgs.width / 2) + n), t.plotY = 1, t.shapeType = "path", t.shapeArgs = { d: this.curvedPath([["M", s, o], ["L", p, o], ["L", p, h], ["L", r, h]], this.options.linkRadius) } }, alignDataLabel: function (t, e, i) { var n, s, o; i.useHTML && (n = t.shapeArgs.width, s = t.shapeArgs.height, o = this.options.borderWidth + 2 * this.options.dataLabels.padding, this.chart.inverted && (n = s, s = t.shapeArgs.width), s -= o, n -= o, (o = e.text) && (h(o.element.parentNode, { width: n + "px", height: s + "px" }), h(o.element, { left: 0, top: 0, width: "100%", height: "100%", overflow: "hidden" })), e.getBBox = function () { return { width: n, height: s } }, e.width = n, e.height = s), r.seriesTypes.column.prototype.alignDataLabel.apply(this, arguments) } }) }), e(t, "masters/modules/organization.src.js", [], function () { }) });